/*
** Translation Table as described in RFC1113
*/
static const char cb64[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

/*
** Translation Table to decode (created by author)
*/
static const char cd64[]="|$$$}rstuvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW$$$$$$XYZ[\\]^_`abcdefghijklmnopq";

/*
** encodeblock
**
** encode 3 8-bit binary bytes as 4 '6-bit' characters
*/
void encodeblock( unsigned char in[3], unsigned char out[4], int len )
{
    out[0] = cb64[ in[0] >> 2 ];
    out[1] = cb64[ ((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
    out[2] = (unsigned char) (len > 1 ? cb64[ ((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6) ] : '=');
    out[3] = (unsigned char) (len > 2 ? cb64[ in[2] & 0x3f ] : '=');
}

void Base64Encode(
    unsigned char* pIn, size_t nInLen,
    unsigned char*& pOut, size_t& nOutLen )
{
    size_t nMod = nInLen%3;
    size_t nGroup = nInLen/3;
    if ( nMod == 0)
    {
        nOutLen = nGroup*4;
    }
    else
    {
        nOutLen = nGroup*4 + 1;
    }

    pOut= new unsigned char[nOutLen];

    unsigned char* pInTmp = pIn;
    unsigned char* pOutTmp = pOut;
    for ( size_t i=0; 
          i<nGroup;
          ++i, pInTmp+=3, pOutTmp+=4 )
    {
        pOutTmp[0] = cb64[ pInTmp[0] >> 2 ];
        pOutTmp[1] = cb64[ ((pInTmp[0] & 0x03) << 4) | ((pInTmp[1] & 0xf0) >> 4) ];
        pOutTmp[2] = cb64[ ((pInTmp[1] & 0x0f) << 2) | ((pInTmp[2] & 0xc0) >> 6) ];
        pOutTmp[3] = cb64[ pInTmp[2] & 0x3f ];
    }

    if ( nMod == 1)
    {
        pOutTmp[0] = cb64[ pInTmp[0] >> 2 ];
        pOutTmp[1] = cb64[ ((pInTmp[0] & 0x03) << 4) ];
        pOutTmp[2] = (unsigned char)'=';
        pOutTmp[3] = (unsigned char)'=';
    }
    else if ( nMod == 2 )
    {
        pOutTmp[0] = cb64[ pInTmp[0] >> 2 ];
        pOutTmp[1] = cb64[ ((pInTmp[0] & 0x03) << 4) | ((pInTmp[1] & 0xf0) >> 4) ];
        pOutTmp[2] = cb64[ ((pInTmp[1] & 0x0f) << 2) ];
        pOutTmp[3] = (unsigned char)'=';
    }
}
