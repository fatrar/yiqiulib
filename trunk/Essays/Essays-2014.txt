


----------------------------------------------------------------------

15:58 2014-3-20

1. 一个引擎实现 实现材质管理的办法
  lua 持有一个C++ 动态数组的ID，  C++有一个动态数组， 数组里面放一个 材质管理的结构体
大体数据结构如下：
struct TTexInfo
{
    QWORD qwHash;
    IPakReader* pPakReader; // 
    IImage2D* pImage2D;     // 使用时为0则重新加载
    time_t LastUserTime;
    int nRef;   // 可能需要

    // 下面为Debug版预留的数据
    string strName;
    int nMemUse;
}

1.动态数组，根据需求变大。
2.管理器可以做两个模式， 
 1. 单实例模式，  适应于小游戏
 2. 默认一个，特殊需求一个， ， 大游戏， 比如系统UI一个。 场景地图一个，根据需求设置最大材质个数或者最大内存数

自动垃圾回收：
1. 垃圾回收策略为 最大材质个数，或者最大内存占用数
2. 达到策略边界回收


2. http做心跳的策略
   基于 HTTP 长连接的“服务器推”技术
 做法如下：
  1. 客户端独立创建 一个 长连接 给 httpserver
  2. 这个连接 一直等待httpServer 超时或者 有数据返回。
  3. 有返回或超时时  继续发起 request

 这个跟 socket 乱序 ， server pull  数据给 client
不足的是， 超时等待再 request 有个小的 时间消耗
好处是， 保持http模式， 一应一答， 框架比较容易做。简单。
  大体思路： 参考网上的文章 --  基于 HTTP 长连接的“服务器推”技术












