



-----------------------------------------------------------
********************* new start ***************************
-----------------------------------------------------------


----------------------------------------------------------------------
10:15 2010-6-7
-- 下面的代码在lua5.1报错
g_Test = 
{
[1254] = 222,
--	555555,
}
for i,v in g_Test do
	--print("%d", i);
	print( i)
	print( v )
end

好久没用lua了，于是就写了个简单的lua代码调式下，顺便试试那个vslua的插件。
没想到，表遍历打印 运行时老是报错。真是不解，以前一直是那么写的。
于是拿以前在冰川的代码看了看，应该不是我写错了。
于是想可能是lua版本的问题，因为以前在冰川运行的lua5.0的，现在设置跑的是5.1的
于是改回去，果然可以。



想起现在要的产品是手机网游，于是在脑海里，冒出来其他平台游戏的想法。
比如以后做PC上的啊。。于是想起了PC上的棋牌游戏。 突然觉得如果做手机的棋牌在线，估计是非常不错的。
而且相对于RPG网游做起来要简单很多，而且收益也非常快。


----------------------------------------------------------------------
11:35 2010-6-10

公司这边开发人员可以选择用笔记本和台式机。由公司购买，笔记本还能带回去。
所以还不如鼓励新来的员工自己去买，公司的补助的方式，这样员工觉得也不错，还可以笔记本的折旧问题公司这边就不需要考虑了。
硬件变化那么快，三年样子以前的机器就比较落后了。
员工购买笔记本的价格不能低于一个数目，限制品牌，按以前的，比如最低不能低于5000，
每个人补贴200，那么也要补贴25个月。


---------------------------------------------------------------------
17:00 2010-6-24

今天打算将vc 自带的stl的hashmap移出来，然后再做下简化，本以为这是件很简单的事情，结果却比我难的。
越到后面，居然跟系统粘在一起了，没想到，stl里面还有lock的函数。。
真是感慨，，还是自己以后慢慢写一个吧，那怕以后不想，也可以练手。。


---------------------------------------------------------------------
11:58 2010-7-1
我们都知道C++中普通函数重载是不能用返回值的类型做区别的。
不过倒是有一招可以解决这个问题，稍微麻烦点。
ex：
template<typename T>
T Test()
{
    return T(0);
}
int a = Test<int>();
bool b = Test<bool>();
麻烦是在调用是需要制定模板类型，毕竟在模板当中普通函数是不需要输入模板参数的


---------------------------------------------------------------------
12:01 2010-7-1
关于lua里面的pairs和ipairs的区别
for key,value in pairs(self) do

pairs不用在table不一种map的方式存在时。 
如： a = {[1]=2,aa=3,[10]="sdfsd"}
ipairs是table是数组的方式时。也就是没有key的概念
如： a = {1,2,3}




---------------------------------------------------------------------
10:24 2010-8-2
现在Iphone这边的移植已进入到后期，大的瓶颈也基本解决。
所以在这个时候需要罗列下还剩那些东西需要做的。


未实现：
1. 得到系统参数
2. 多点触摸处理
3. 重力感应及屏幕旋转及带来的坐标变换
4. 声音
5. 在游戏进行当中，收到短信，电话的异常处理 
6. 输入法

bug
1. 网络部分及异常处理
2. opengl渲染部分，在程序结束时没内存释放

其他：
1. 注册苹果开发者计划

现在游戏这边已经可以到登录界面了，以前声音没动他，就是说不好测。
所以安排沈孝星专心去做声音部分。
而我这边主要先把网络给调通，这部分以前是写过，但是跑起来是有bug的。
按估计Iphone这边我大概在这周能结束。
我这边剩下的主要解决渲染和网络。

---------------------------------------------------------------------
10:24 2010-8-6
总结这周：
1.网络部分Get调通，顺带将选择接入点的界面在lua里面过滤掉，将改的给廖苏洲，毕竟他那边也需要这个。
  所以也能进村子了。
2.因为现在我们屏幕旋转了，系统发过来的坐标是需要处理再发给lua，处理坐标
3.输入法，这部分已经出来了，也解决了他在iphone里面旋转的问题。但是就是不知道在获取用户后，如何发给lua
4.注册苹果开发者计划， 进行中
5.过滤掉多点触摸
6.得到系统参数， 进行中，实现了几个

还需要关心的：
1.输入法
2.进入村子在比武和深渊会Crash，因为我这边画布现在只是读一个写死的长宽的。
  而比武和深渊画布大小变了，导致内存越界访问，这部分我在解决输入法后解决，关键是看输入法是否在要旋转整个系统坐标。
  这样的话，openGL显示会也要对应的更改，现在的openGL显示不是用opengl的API去旋转画出来，而是在copy数据时旋转后来，


---------------------------------------------------------------------
9:46 2010-8-10 

需要在实际的手机确认
1. [?]多点触摸处理
2. [?]IPhone显示是否正常
3. [?]声音

未实现：
1. []得到系统参数
2. 在游戏进行当中，本来手机的一些事件处理
 游戏当中  收到短信，电话，电量不足异常处理
3. 注册苹果开发者计划
4. 合并1.0的代码

bug：
1. 网络部分异常处理
2. opengl渲染部分，看还有那些显示问题
3. []输入法
   调整位置
4. 退出不了。
   原因在于lua发消息过来，界面部分没处理退出
5. 比武位置
其他：1. 充值

目标：月底跟其他平台一起出iphone版本的1.0

工作分配：
heliang:
1. 比武位置
2. 输入法中文兼容问题
3. 声音 --> 戏进行当中，本来手机的一些事件处理-->合并1.0的代码

沈孝星:
1. 深渊坐标
2. 退出不了 
3. 输入法坐标调整
4. 网络部分异常处理
5. 得到系统参数
6. 充值


---------------------------------------------------------
17:02 2010-8-13

程序优化：
1.现有程序结束，还有一些资源没有释放
2.声音、网络线程结束不安全
3.现有其他代码优化，及补充注释
4.查程序内存是否有泄漏

未实现，未做的功能：
1. 在游戏进行当中，本来手机的一些事件处理
   游戏当中 收到短信，电话，电量不足异常处理
2. 注册苹果开发者计划
3. 合并1.0的代码
4. 程序打包研究，及程序图片，及需要美术这边提供的logo图
5. 程序Rlease版工程配置
6. 取系统参数
7. 合并1.0的代码

真机上可能会有问题：
1. 现有openGL贴图，可能在IPhone4 屏幕分辩率下显示不正常
2. 充值测试
3. 取系统参数

下周目标：
如果苹果开发者计划成功：提供第一个可以在IPhone上跑的(0.99) alpha版

heliang：
1. 现有程序结束，还有一些资源没有释放
2. 声音、网络线程结束不安全
3. 现有其他代码优化，及补充注释
4. 查程序内存是否有泄漏
5. 研究OpenGL es贴图
6. 注册苹果开发者计划

sx:
1. 程序打包研究，及程序图片，及需要美术这边提供的logo图
2. 程序Rlease版工程配置
3. 取系统参数
4. 在游戏进行当中，本来手机的一些事件处理
   游戏当中 收到短信，电话，电量不足异常处理

剩下：
合并1.0的代码


---------------------------------------------------------
17:02 2010-8-23

上周我和沈孝星主要是做程序的收尾部分。为即将上真机，乃至上传苹果商店做准备。
工作内容如下：
1. 程序打包研究，及程序图片，及需要美术这边提供的logo图
2. 程序Rlease版工程配置
3. 取系统参数（等真机确认）
4. 在游戏进行当中，本来手机的一些事件处理
   游戏当中 收到短信，电话，电量不足异常处理（这个貌似以前就实现了。等真机实际测试）
5. 代码的优化，及补充注释（未完成）。
6. 查程序内存是否有泄漏
   用Apple的查内存工具，查出不少客户端原有代码的内存泄露。
   现在还测出网络，声音部分也有内存泄露，这个需要后面的研究确认，以现有网上的资料，说是sdk本身的问题。
7. 注册苹果开发者计划
8. 将程序上真机测试，现在跑起来除了提示有上面说的内存泄露，还有密码保存不了，这个原因是存密码的目录没有权限写。
    上真机的平台包括Ipod 3.12，3.13，4.0， iphone 3.12


这周的需要做的事情：
1. 解决是否真的有内存泄露
2. 密码保存问题
3. 合并客户端1.0的代码
4. 打包及上苹果商店
5. 继续代码优化及调整
6. 现有程序结束，还有一些资源没有释放
7. 测试和确认一些功能在真机是否OK： 
   a 在游戏进行当中，本来手机的一些事件处理
   b 系统参数
   c 充值


贺亮：
1. 解决是否真的有内存泄露
2. 合并客户端1.0的代码
3. 继续代码优化及调整
4. 现有程序结束，还有一些资源没有释放


sx：
1. 密码保存问题
2. 打包及上苹果商店
3. 测试和确认一些功能在真机是否OK： 
   a 在游戏进行当中，本来手机的一些事件处理
   b 系统参数
   c 充值


目标：
周二下班前，上传第一版程序到苹果商店（最迟周三）
最后上传一版苹果商店的软件



---------------------------------------------------------
11:15 2010-8-30
上周工作总结：
1. iphone部分工作一些简单的交接
2. iphone 渲染部分openGL的优化，
   以现在的了解应该更改一些OpenGL API来提高的性能的可能性应该不大。
   所以从渲染的流程上改，应该是解决这个性能瓶颈的关键。
3. OpenGL 渲染的研究

本周计划：
1. OpenGL 渲染的继续研究
2. 熟悉现有代码跑到流程，为以后改渲染流程提供参考。
3. 提交新的渲染方案，及实施方案



---------------------------------------------------------
17:06 2010-8-30
备注： 如无特别什么下列说的OpenGL是指OpenGL ES，以后也是如此。

关于渲染部分研究的想法：
以现在的状况而言，我们以前有点太高估与openGL的能力，导致自己觉得一直是自己对OpenGL不了解，用了性能不高的方法去贴图。
所以我们需要论证下，openGL到底多大的能力，是我们理解不够导致我们没有把它用对地方，还是我们对他期望太高。

所以我的第一步工作应该是，目标很简单：验证OpenGL的能力，附带提高自己对OpenGL的认识
1. 论证OpenGL 以现有方式到底最大能达到多少帧
   这个部分可以分为接下来几个测试。
  A， 一个纯贴图界面，以每次贴 copy 320×480的数据到512×512的buf，然后绑定Buf到材质，然后贴出来。
  B， 几乎跟上面一样，不同是只做一次copy，以后全部只是显示
  C， 做一个背景只做Copy一次，然后有很多动画让其与一个小材质去更新，没次更新材质，然后贴出来。
  D， C测试加上多个材质
2. 具体修改方案简单模型测试（这个等第一步确认后再决定如何做）

先OpenGl的资料，然后再做测试。
虽然自己而言非常想马上就做这个测试，但是理论知识深入会对测试，自我学习有促进。

---------------------------------------------------------
10:27 2010-9-2

今天突然觉得要实现最大化的利用GPU，其实还有一部分就是RXImage中的一些Bit方法。
我列出来好了，研究下是否能全部交给GPU去实现
源代码没有注释，对于那些没有图像概念的人，是中折磨，我先列出来。
罗列方式以三个为一组，第一行是原函数的愿意，第二行是函数申明，
第三行OpenGL的可行的实现方案，X代表需要CPU做

所有的图都映射到一个材质

直接贴图
Blt(CCanvas* canvas,int x,int y) const;
将材质显示在指定位置

贴图+用一个指定的Alpha值
BltA(CCanvas* canvas,int x,int y,TUint8 a8) const;
将材质显示在指定位置+glColorPointer，设置Alpha

贴图中一部分到画布
BltClip(CCanvas* canvas,int x,int y,int cx,int cy,int cw,int ch) const;
将材质显示在指定位置+glTexCoordPointer改材质坐标

贴图中一部分到画布且带Alpha值贴
BltClipA(CCanvas* canvas,int x,int y,int cx,int cy,int cw,int ch,TUint8 a8) const;
将材质显示在指定位置+glTexCoordPointer改材质坐标+glColorPointer设置Alpha

将图中指定区域的图贴到画布区域，如果两个区域大小不一致，就缩放
BltZoom(CCanvas* canvas,int srcX,int srcY,int srcW,int srcH,int dstX,int dstY,int dstW,int dstH,float=-1) const;
glVertexPointer设置需要显示部分+glScale缩放

将图中指定区域的图+Alpha值贴到画布区域，如果两个区域大小不一致，就缩放
BltZoomA(CCanvas* canvas,int srcX,int srcY,int srcW,int srcH,int dstX,int dstY,int dstW,int dstH,TUint8 a8,float=-1) const;
glScalef+glColorPointer设置Alpha

贴一张水平翻转的图到画布
BltFlipH(CCanvas* canvas,int x,int y) const;
glRotatef(180,0,0,1)

贴一张垂直翻转的图到画布
BltFlipV(CCanvas* canvas,int x,int y) const;
glRotatef(180,1,0,0)

贴一张即水平又垂直翻转的图到画布
BltFlipHV(CCanvas* canvas,int x,int y) const;
glRotatef(180,1,0,1)

贴一张水平翻转的图+蒙色到画布
BltFlipH_ColorCoat(CCanvas* canvas,int x,int y,int rgb888,TUint8 a8) const;

贴一张水平翻转的图+Alpha到画布
BltFlipHA(CCanvas* canvas,int x,int y,TUint8 a8) const;

贴一张图+蒙色到画布
BltColorCoat(CCanvas* canvas,int x,int y,int rgb888,TUint8 a8) const;

复制一份
RXImage* Clone() const;

复制一份带缩放，里面参数为目标区域的宽高
RXImage* CloneZoom(int czw,int czh) const;

调整如的色调与灰阶
void HueAdjust(int hueDelta, TUint8 grayLevel8B=0);


---------------------------------------------------------
8:51 2010-9-7
昨天终于把OpenGL测试做完了，大体跟我想的差不多。




记得去找 
vx 里面
/**CPP*************************************************************************
 File            : Canvas.cpp
 Subsystem       :  <-- 这个vx自动生成，代表意思应该为 工程名
 Function Name(s): CCanvas


---------------------------------------------------------
14:15 2010-9-16
---------------------------------------------------------

查下现在主流的手机，对openGL es的支持。 都支持到那个版本


---------------------------------------------------------
10:22 2010-9-19

工作总结
1. 将贴图部分由一张材质贴（512×512），变为两张贴（256×512 + 64×512）。从而减少数量量，从而提高效率。
2. 移植飞机到Iphone上。
   现有的飞机用xStar是用单机的。有些东西还是有些不一样。
3. 写客户端打包的需求分析及解决方案和甘特图

工作计划:
按甘特图开始做打包的功能


---------------------------------------------------------
15:18 2010-9-19
以前在冰川的时候，陈涛用了一种命令模式去解决控制台命令去解决命令与实际跑的程序的关系。
在我们大部分的程序中，我们如果对某个程序运行时输入命令。
我们一般的做法是：
在main函数里面，将每个命令解析，如果是正确的预订的格式话，肯定Switch出一个结果然后做对应的处理。
这样做的问题是，命令本身的格式与于命令出发的事件绑的很紧。而且命令解析在以后的类似的系统这部分代码需要重复写。

我的想法是，我们设计一个命令格式然后由指定的解析器解析，实际执行命令的模块只负责设个回调给命令解析器。
告诉解析器当你解析成这个命令时，回调这个函数处理。
说白了这个的目地就是想让命令格式与命令执行逻辑剥离。确认一种命令格式后，以后就全用他了。以后的命令解析就不用再写了。
再说有个固定的命令格式，对使用者肯定是要方便的。

---------------------------------------------------------
13:52 2010-9-20
今天研究7z算法时，想在网上找找网上对7Z，其实最主要是看看他们觉得7z有哪些瑕疵。
结果我发现网上有个家伙推荐另外一个开源压缩算法 FreeArc 0.666。
http://www.magicie.com/html/6131.html
 他比7z。 压缩率更高，解压速度更快，。  但是考虑到跨平台还是选择用7z。毕竟他被大家所熟悉，且从版本号上看发行时间比FreeArc长，估计也会较FreeArc稳定。
  我对手机游戏资源包压缩算法的需要是这样的：（第一个最重要，到最后最其次）
    1. 易跨平台，稳定, 如果其他平台都不能移植，或者移植很难。这本身就违背我们跨平台引擎的设计理念。 
    2. 解压占用内存少，由于手机上内存较低，必须这样，特别是塞班这边。其他平台这个还好
    3. 速度快， 由于手机上CPU性能有限。不过一般的解压缩算法都会考虑到这个问题，所以一般的算法都会出现压缩慢，而解压快。
    4. 压缩率高。 主要方便用户更新我们的资源。减少网络的数据流量

  以上是我自己一个游戏资源包需要的。所以才会有这样的取舍。毕竟FreeArc官方只说现在支持linux和window。我很难肯定今后移植到iphone和塞班上会有什么问题。不过我相信Andriod应该还好。毕竟andriod就是linux的派生。

---------------------------------------------------------
12:19 2010-9-21
因为今后我这边要大量使用文件的相关的操作，考虑到跨平台的因素。所以我不想后期移植到其他平台时折腾。
所以想 实现一个文件操作类，先交他CFile吧。这样以后关于文件的平台操作就给他了。我以后业务相关的文件操作代码就知道用它。
这样就使我这边的代码与具体平台剥离。其次这样代码也相对要干净不少，没有在业务中有太多的 宏。
于是跟廖苏州讨论了下 这个东西具体的接口和实现方式。


---------------------------------------------------------
23:02 2010-9-25
一、关于CFile的跨平台实现构思
今天把做CFile类的基本方法是定下来，并顺便把自己熟悉的Windows这边的给实现了。
本应想继续将塞班这边的也做了，本以为可以用fopen之类的C方式给解决，解决发现这一系列API，很实现关于文件截断和文件删除的功能。其实在文件操作中，还有一个POSIX的文件接口方式。比如他的打开文件的函数名为open。 在这里顺便做关于文件操作的一些总结吧。

在window平台其实有至少5种方式访问文件（除去驱动访问，及DDK方式），
1. Windows自己提供的API，比如CreateFile
    功能强大，且因为操作直接，所以效率很高。能满足我这边所有的需求，问题就是不能跨平台。
    所以我拿它做window这边的实现。
2. 标准C的方式，比如fopen
    能跨平台，功能上只是显现基本的文件操作。window平台下，是间接调用Windows API实现功能（比如fopen最终是调用CreateFile）。所以效率稍差，还有文件打开用的属性标记居然用字符串。比如"a+b"。所以到API对应打开的属性需要字符串解析。老实说真不知道当初那些定这个API的人的想法。导致效率又低，且还有功能局限性（有些属性没办法用这些字符串组合实现）。
3. POSIX API，比如open
   UNIX标准接口，window本身也实现了部分。linux也有对于的实现。所以跨平台也还不错。我找了下。塞班也支持，不过支持有限，有些函数和功能还有有些限制。这个系列属于且低级的文件操作，操作效率还可以。且功能强大。所以我打算Iphone上用它去实现。Andriod如果支持的话，也可以考虑用他。
在windows平台是调Windows API实现，调用比较直接几乎没有其他中间层。
4. MFC的CFile类（到vs2003以后是MFC和ATL的共用，不再MFC独有）
   基本上是封装了Windows本身的API，所以功能算是很强大，效率也不错，问题也是不能跨平台。
5. STL的fstream
   因为是个标准，所以在各个平台都有实现，但可能每个平台具体实现会不一样，在window的STL fstream他最终调用的标准C的文件操作类。
   所以他的特性几乎跟C一样，跨平台部分当然要比C方式要差，毕竟某些平台对STL支持不是很好。
   
塞班上：
今天看了3版的接口，貌似POSIX API支持有限，估计不能实现我所有的功能，不过发现有RFile类可以实现大部分的功能。所以打开用它去实现。

二、代码组织
一直以来，我们的为了让代码可以跨平台，许多函数和类里面包含了许多的编译宏，在多个平台下，简直让代码可读性急剧下降。我在这给我一直以来这方面的一些思考。

头文件处理：
如果头文件大部分是一样，那么就简单像以前一样，加几个编译宏处理。
但是如果头文件会有很多不一样，最好在这个头文件中只是在编译宏中，再包含真正的头文件。比如：
在这头文件中写下这样
#ifdefine _win32
   #include "xx_window.h"
#elif __APPLE__
   #include "xx_ios.h"
#else
   #error unsupport system
#end
而最终包含的则是实现需要的。

CPP处理：
这部分也是和头文件基本一样，如果代码部分大部分一样，就像以前那样处理。
如果很多不一样，就直接在cpp 用编译宏，在包含真正实现CPP（C++/C是可以用#include包含Cpp，或者C的）。
不过要注意，耐心哦真正平台的那些CPP，在工程配置中不能做为编译的代码处理。
否则会导致链接错误------>重定义错误
如下：
#ifdefine _win32
   #include "xx_window.cpp"
#elif __APPLE__
   #include "xx_ios.cpp"
#else
   #error unsupport system
#end

而在代码目录我是建议，每个平台单独放一个目录，放其独有的实现。比如头文件

-- xx.h
-- window +
                -- xx_window.h
-- ios        +
                -- xx_ios.h
说白了。工程文件如下： 
第一层文件有 xx.h，文件夹有window和ios
而window文件夹有  xx_window.h
而ios文件夹有 xx_ios.h

这样自我感觉代码目录的结构要清晰很多。






























