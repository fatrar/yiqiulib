int i = 1;
_arm
{
MOV Rx, i
Rx, ROR 31
MOV Rx, i
}


-----------------------------------------------------------
********************* new start ***************************
-----------------------------------------------------------


----------------------------------------------------------------------
10:15 2010-6-7
-- 下面的代码在lua5.1报错
g_Test = 
{
[1254] = 222,
--	555555,
}
for i,v in g_Test do
	--print("%d", i);
	print( i)
	print( v )
end

好久没用lua了，于是就写了个简单的lua代码调式下，顺便试试那个vslua的插件。
没想到，表遍历打印 运行时老是报错。真是不解，以前一直是那么写的。
于是拿以前在冰川的代码看了看，应该不是我写错了。
于是想可能是lua版本的问题，因为以前在冰川运行的lua5.0的，现在设置跑的是5.1的
于是改回去，果然可以。



想起现在要的产品是手机网游，于是在脑海里，冒出来其他平台游戏的想法。
比如以后做PC上的啊。。于是想起了PC上的棋牌游戏。 突然觉得如果做手机的棋牌在线，估计是非常不错的。
而且相对于RPG网游做起来要简单很多，而且收益也非常快。


----------------------------------------------------------------------
11:35 2010-6-10

公司这边开发人员可以选择用笔记本和台式机。由公司购买，笔记本还能带回去。
所以还不如鼓励新来的员工自己去买，公司的补助的方式，这样员工觉得也不错，还可以笔记本的折旧问题公司这边就不需要考虑了。
硬件变化那么快，三年样子以前的机器就比较落后了。
员工购买笔记本的价格不能低于一个数目，限制品牌，按以前的，比如最低不能低于5000，
每个人补贴200，那么也要补贴25个月。


---------------------------------------------------------------------
17:00 2010-6-24

今天打算将vc 自带的stl的hashmap移出来，然后再做下简化，本以为这是件很简单的事情，结果却比我难的。
越到后面，居然跟系统粘在一起了，没想到，stl里面还有lock的函数。。
真是感慨，，还是自己以后慢慢写一个吧，那怕以后不想，也可以练手。。


---------------------------------------------------------------------
11:58 2010-7-1
我们都知道C++中普通函数重载是不能用返回值的类型做区别的。
不过倒是有一招可以解决这个问题，稍微麻烦点。
ex：
template<typename T>
T Test()
{
    return T(0);
}
int a = Test<int>();
bool b = Test<bool>();
麻烦是在调用是需要制定模板类型，毕竟在模板当中普通函数是不需要输入模板参数的


---------------------------------------------------------------------
12:01 2010-7-1
关于lua里面的pairs和ipairs的区别
for key,value in pairs(self) do

pairs不用在table不一种map的方式存在时。 
如： a = {[1]=2,aa=3,[10]="sdfsd"}
ipairs是table是数组的方式时。也就是没有key的概念
如： a = {1,2,3}




---------------------------------------------------------------------
10:24 2010-8-2
现在Iphone这边的移植已进入到后期，大的瓶颈也基本解决。
所以在这个时候需要罗列下还剩那些东西需要做的。


未实现：
1. 得到系统参数
2. 多点触摸处理
3. 重力感应及屏幕旋转及带来的坐标变换
4. 声音
5. 在游戏进行当中，收到短信，电话的异常处理 
6. 输入法

bug
1. 网络部分及异常处理
2. opengl渲染部分，在程序结束时没内存释放

其他：
1. 注册苹果开发者计划

现在游戏这边已经可以到登录界面了，以前声音没动他，就是说不好测。
所以安排沈孝星专心去做声音部分。
而我这边主要先把网络给调通，这部分以前是写过，但是跑起来是有bug的。
按估计Iphone这边我大概在这周能结束。
我这边剩下的主要解决渲染和网络。

---------------------------------------------------------------------
10:24 2010-8-6
总结这周：
1.网络部分Get调通，顺带将选择接入点的界面在lua里面过滤掉，将改的给廖苏洲，毕竟他那边也需要这个。
  所以也能进村子了。
2.因为现在我们屏幕旋转了，系统发过来的坐标是需要处理再发给lua，处理坐标
3.输入法，这部分已经出来了，也解决了他在iphone里面旋转的问题。但是就是不知道在获取用户后，如何发给lua
4.注册苹果开发者计划， 进行中
5.过滤掉多点触摸
6.得到系统参数， 进行中，实现了几个

还需要关心的：
1.输入法
2.进入村子在比武和深渊会Crash，因为我这边画布现在只是读一个写死的长宽的。
  而比武和深渊画布大小变了，导致内存越界访问，这部分我在解决输入法后解决，关键是看输入法是否在要旋转整个系统坐标。
  这样的话，openGL显示会也要对应的更改，现在的openGL显示不是用opengl的API去旋转画出来，而是在copy数据时旋转后来，


---------------------------------------------------------------------
9:46 2010-8-10 

需要在实际的手机确认
1. [?]多点触摸处理
2. [?]IPhone显示是否正常
3. [?]声音

未实现：
1. []得到系统参数
2. 在游戏进行当中，本来手机的一些事件处理
 游戏当中  收到短信，电话，电量不足异常处理
3. 注册苹果开发者计划
4. 合并1.0的代码

bug：
1. 网络部分异常处理
2. opengl渲染部分，看还有那些显示问题
3. []输入法
   调整位置
4. 退出不了。
   原因在于lua发消息过来，界面部分没处理退出
5. 比武位置
其他：1. 充值

目标：月底跟其他平台一起出iphone版本的1.0

工作分配：
heliang:
1. 比武位置
2. 输入法中文兼容问题
3. 声音 --> 戏进行当中，本来手机的一些事件处理-->合并1.0的代码

沈孝星:
1. 深渊坐标
2. 退出不了 
3. 输入法坐标调整
4. 网络部分异常处理
5. 得到系统参数
6. 充值


---------------------------------------------------------
17:02 2010-8-13

程序优化：
1.现有程序结束，还有一些资源没有释放
2.声音、网络线程结束不安全
3.现有其他代码优化，及补充注释
4.查程序内存是否有泄漏

未实现，未做的功能：
1. 在游戏进行当中，本来手机的一些事件处理
   游戏当中 收到短信，电话，电量不足异常处理
2. 注册苹果开发者计划
3. 合并1.0的代码
4. 程序打包研究，及程序图片，及需要美术这边提供的logo图
5. 程序Rlease版工程配置
6. 取系统参数
7. 合并1.0的代码

真机上可能会有问题：
1. 现有openGL贴图，可能在IPhone4 屏幕分辩率下显示不正常
2. 充值测试
3. 取系统参数

下周目标：
如果苹果开发者计划成功：提供第一个可以在IPhone上跑的(0.99) alpha版

heliang：
1. 现有程序结束，还有一些资源没有释放
2. 声音、网络线程结束不安全
3. 现有其他代码优化，及补充注释
4. 查程序内存是否有泄漏
5. 研究OpenGL es贴图
6. 注册苹果开发者计划

sx:
1. 程序打包研究，及程序图片，及需要美术这边提供的logo图
2. 程序Rlease版工程配置
3. 取系统参数
4. 在游戏进行当中，本来手机的一些事件处理
   游戏当中 收到短信，电话，电量不足异常处理

剩下：
合并1.0的代码

---------------------------------------------------------
22:52 2010-8-15
我们经常在读写一个类的成员时，经常会写针对该成员的读写函数，这样就比较符合面向对象的思想。
但是照这个方式，如果需要读写多个类成员，相应的读写函数会写很多个。会非常麻烦。
导致整个类体好多简单的类函数，增加该类的复杂性。
这种情况有个常用的简单方法，用友元或者直接把需要读写成员直接public。
唯一的缺陷就是破坏了面向对象的封装。

在游戏里有些数据管理的类，有非常多的数据是需要读写的。
所以他们的做法，用两个函数一个读，一个写。函数定义为下：
class CMgr
{
public:
    enum Attribute
    {
        Height,
        Width,
        Age,
    };
 
   void GetValue(Attributet a, int &v)
    {
         switch(a)
        {
        case Height: v = m_Height;break;
        case Width: v=m_Width;break;
        case Age: v= m_age;break;
        }
    }
int m_Height, m_Width, m_age;
}

貌似这个方式解决了这个问题，但是却带了一个问题。
不知道你有没有看出，我觉得性能太差，为了获取一个数据判断那么多次。
特别属性很多时，性能呈几何下降， jmp指令在汇编是很慢的，且打断CPU的流水线。


所以我今天突然想出一个针对这个方法的改进办法。

class CMgr
{
public:
    CMgr()
    {
        memset(this, 0, sizeof(CMgr));
        a[2] = 1;
    }
    enum Int_Type
    {
        One,
        Two,
        Three,
    };

    enum Point_Type
    {
        Name,
    };

    void GetValue(Int_Type t, int &v)
    {
        v = a[t];
    }
private:
    union
    {
        int a[4];
        struct
        {
            int a1;
            int a2;
            int a3;
            int a4;
        } aa;
    };
};

实际这个GetValue可以写成一个模板，去针对不类型
但是实现我还没想到一个很好的方法。莫非要模板特化所以的类型？
即：
   template<typename T>
    void GetValue(T t, int &v)
    {
        v = a[t];
    }

第一个参数获取那个属性，然后返回值。

这个方法似乎解决了前者问题，但是却带来类函数自己读写成员的麻烦。
毕竟还是要加aa。 虽然用默认联合减少了一层


---------------------------------------------------------
17:02 2010-8-23

上周我和沈孝星主要是做程序的收尾部分。为即将上真机，乃至上传苹果商店做准备。
工作内容如下：
1. 程序打包研究，及程序图片，及需要美术这边提供的logo图
2. 程序Rlease版工程配置
3. 取系统参数（等真机确认）
4. 在游戏进行当中，本来手机的一些事件处理
   游戏当中 收到短信，电话，电量不足异常处理（这个貌似以前就实现了。等真机实际测试）
5. 代码的优化，及补充注释（未完成）。
6. 查程序内存是否有泄漏
   用Apple的查内存工具，查出不少客户端原有代码的内存泄露。
   现在还测出网络，声音部分也有内存泄露，这个需要后面的研究确认，以现有网上的资料，说是sdk本身的问题。
7. 注册苹果开发者计划
8. 将程序上真机测试，现在跑起来除了提示有上面说的内存泄露，还有密码保存不了，这个原因是存密码的目录没有权限写。
    上真机的平台包括Ipod 3.12，3.13，4.0， iphone 3.12


这周的需要做的事情：
1. 解决是否真的有内存泄露
2. 密码保存问题
3. 合并客户端1.0的代码
4. 打包及上苹果商店
5. 继续代码优化及调整
6. 现有程序结束，还有一些资源没有释放
7. 测试和确认一些功能在真机是否OK： 
   a 在游戏进行当中，本来手机的一些事件处理
   b 系统参数
   c 充值


贺亮：
1. 解决是否真的有内存泄露
2. 合并客户端1.0的代码
3. 继续代码优化及调整
4. 现有程序结束，还有一些资源没有释放


sx：
1. 密码保存问题
2. 打包及上苹果商店
3. 测试和确认一些功能在真机是否OK： 
   a 在游戏进行当中，本来手机的一些事件处理
   b 系统参数
   c 充值


目标：
周二下班前，上传第一版程序到苹果商店（最迟周三）
最后上传一版苹果商店的软件



---------------------------------------------------------
11:15 2010-8-30
上周工作总结：
1. iphone部分工作一些简单的交接
2. iphone 渲染部分openGL的优化，
   以现在的了解应该更改一些OpenGL API来提高的性能的可能性应该不大。
   所以从渲染的流程上改，应该是解决这个性能瓶颈的关键。
3. OpenGL 渲染的研究

本周计划：
1. OpenGL 渲染的继续研究
2. 熟悉现有代码跑到流程，为以后改渲染流程提供参考。
3. 提交新的渲染方案，及实施方案



---------------------------------------------------------
17:06 2010-8-30
备注： 如无特别什么下列说的OpenGL是指OpenGL ES，以后也是如此。

关于渲染部分研究的想法：
以现在的状况而言，我们以前有点太高估与openGL的能力，导致自己觉得一直是自己对OpenGL不了解，用了性能不高的方法去贴图。
所以我们需要论证下，openGL到底多大的能力，是我们理解不够导致我们没有把它用对地方，还是我们对他期望太高。

所以我的第一步工作应该是，目标很简单：验证OpenGL的能力，附带提高自己对OpenGL的认识
1. 论证OpenGL 以现有方式到底最大能达到多少帧
   这个部分可以分为接下来几个测试。
  A， 一个纯贴图界面，以每次贴 copy 320×480的数据到512×512的buf，然后绑定Buf到材质，然后贴出来。
  B， 几乎跟上面一样，不同是只做一次copy，以后全部只是显示
  C， 做一个背景只做Copy一次，然后有很多动画让其与一个小材质去更新，没次更新材质，然后贴出来。
  D， C测试加上多个材质
2. 具体修改方案简单模型测试（这个等第一步确认后再决定如何做）

先OpenGl的资料，然后再做测试。
虽然自己而言非常想马上就做这个测试，但是理论知识深入会对测试，自我学习有促进。

---------------------------------------------------------
10:27 2010-9-2

今天突然觉得要实现最大化的利用GPU，其实还有一部分就是RXImage中的一些Bit方法。
我列出来好了，研究下是否能全部交给GPU去实现
源代码没有注释，对于那些没有图像概念的人，是中折磨，我先列出来。
罗列方式以三个为一组，第一行是原函数的愿意，第二行是函数申明，
第三行OpenGL的可行的实现方案，X代表需要CPU做

所有的图都映射到一个材质

直接贴图
Blt(CCanvas* canvas,int x,int y) const;
将材质显示在指定位置

贴图+用一个指定的Alpha值
BltA(CCanvas* canvas,int x,int y,TUint8 a8) const;
将材质显示在指定位置+glColorPointer，设置Alpha

贴图中一部分到画布
BltClip(CCanvas* canvas,int x,int y,int cx,int cy,int cw,int ch) const;
将材质显示在指定位置+glTexCoordPointer改材质坐标

贴图中一部分到画布且带Alpha值贴
BltClipA(CCanvas* canvas,int x,int y,int cx,int cy,int cw,int ch,TUint8 a8) const;
将材质显示在指定位置+glTexCoordPointer改材质坐标+glColorPointer设置Alpha

将图中指定区域的图贴到画布区域，如果两个区域大小不一致，就缩放
BltZoom(CCanvas* canvas,int srcX,int srcY,int srcW,int srcH,int dstX,int dstY,int dstW,int dstH,float=-1) const;
glVertexPointer设置需要显示部分+glScale缩放

将图中指定区域的图+Alpha值贴到画布区域，如果两个区域大小不一致，就缩放
BltZoomA(CCanvas* canvas,int srcX,int srcY,int srcW,int srcH,int dstX,int dstY,int dstW,int dstH,TUint8 a8,float=-1) const;
glScalef+glColorPointer设置Alpha

贴一张水平翻转的图到画布
BltFlipH(CCanvas* canvas,int x,int y) const;
glRotatef(180,0,0,1)

贴一张垂直翻转的图到画布
BltFlipV(CCanvas* canvas,int x,int y) const;
glRotatef(180,1,0,0)

贴一张即水平又垂直翻转的图到画布
BltFlipHV(CCanvas* canvas,int x,int y) const;
glRotatef(180,1,0,1)

贴一张水平翻转的图+蒙色到画布
BltFlipH_ColorCoat(CCanvas* canvas,int x,int y,int rgb888,TUint8 a8) const;

贴一张水平翻转的图+Alpha到画布
BltFlipHA(CCanvas* canvas,int x,int y,TUint8 a8) const;

贴一张图+蒙色到画布
BltColorCoat(CCanvas* canvas,int x,int y,int rgb888,TUint8 a8) const;

复制一份
RXImage* Clone() const;

复制一份带缩放，里面参数为目标区域的宽高
RXImage* CloneZoom(int czw,int czh) const;

调整如的色调与灰阶
void HueAdjust(int hueDelta, TUint8 grayLevel8B=0);


---------------------------------------------------------
8:51 2010-9-7
昨天终于把OpenGL测试做完了，大体跟我想的差不多。




记得去找 
vx 里面
/**CPP*************************************************************************
 File            : Canvas.cpp
 Subsystem       :  <-- 这个vx自动生成，代表意思应该为 工程名
 Function Name(s): CCanvas


---------------------------------------------------------
14:15 2010-9-16
---------------------------------------------------------

查下现在主流的手机，对openGL es的支持。 都支持到那个版本


---------------------------------------------------------
10:22 2010-9-19

工作总结
1. 将贴图部分由一张材质贴（512×512），变为两张贴（256×512 + 64×512）。从而减少数量量，从而提高效率。
2. 移植飞机到Iphone上。
   现有的飞机用xStar是用单机的。有些东西还是有些不一样。
3. 写客户端打包的需求分析及解决方案和甘特图

工作计划:
按甘特图开始做打包的功能


---------------------------------------------------------
15:18 2010-9-19
以前在冰川的时候，陈涛用了一种命令模式去解决控制台命令去解决命令与实际跑的程序的关系。
在我们大部分的程序中，我们如果对某个程序运行时输入命令。
我们一般的做法是：
在main函数里面，将每个命令解析，如果是正确的预订的格式话，肯定Switch出一个结果然后做对应的处理。
这样做的问题是，命令本身的格式与于命令出发的事件绑的很紧。而且命令解析在以后的类似的系统这部分代码需要重复写。

我的想法是，我们设计一个命令格式然后由指定的解析器解析，实际执行命令的模块只负责设个回调给命令解析器。
告诉解析器当你解析成这个命令时，回调这个函数处理。
说白了这个的目地就是想让命令格式与命令执行逻辑剥离。确认一种命令格式后，以后就全用他了。以后的命令解析就不用再写了。
再说有个固定的命令格式，对使用者肯定是要方便的。

---------------------------------------------------------
13:52 2010-9-20
今天研究7z算法时，想在网上找找网上对7Z，其实最主要是看看他们觉得7z有哪些瑕疵。
结果我发现网上有个家伙推荐另外一个开源压缩算法 FreeArc 0.666。
http://www.magicie.com/html/6131.html
 他比7z。 压缩率更高，解压速度更快，。  但是考虑到跨平台还是选择用7z。毕竟他被大家所熟悉，且从版本号上看发行时间比FreeArc长，估计也会较FreeArc稳定。
  我对手机游戏资源包压缩算法的需要是这样的：（第一个最重要，到最后最其次）
    1. 易跨平台，稳定, 如果其他平台都不能移植，或者移植很难。这本身就违背我们跨平台引擎的设计理念。 
    2. 解压占用内存少，由于手机上内存较低，必须这样，特别是塞班这边。其他平台这个还好
    3. 速度快， 由于手机上CPU性能有限。不过一般的解压缩算法都会考虑到这个问题，所以一般的算法都会出现压缩慢，而解压快。
    4. 压缩率高。 主要方便用户更新我们的资源。减少网络的数据流量

  以上是我自己一个游戏资源包需要的。所以才会有这样的取舍。毕竟FreeArc官方只说现在支持linux和window。我很难肯定今后移植到iphone和塞班上会有什么问题。不过我相信Andriod应该还好。毕竟andriod就是linux的派生。

---------------------------------------------------------
12:19 2010-9-21
因为今后我这边要大量使用文件的相关的操作，考虑到跨平台的因素。所以我不想后期移植到其他平台时折腾。
所以想 实现一个文件操作类，先交他CFile吧。这样以后关于文件的平台操作就给他了。我以后业务相关的文件操作代码就知道用它。
这样就使我这边的代码与具体平台剥离。其次这样代码也相对要干净不少，没有在业务中有太多的 宏。
于是跟廖苏州讨论了下 这个东西具体的接口和实现方式。


---------------------------------------------------------
23:02 2010-9-25
一、关于CFile的跨平台实现构思
今天把做CFile类的基本方法是定下来，并顺便把自己熟悉的Windows这边的给实现了。
本应想继续将塞班这边的也做了，本以为可以用fopen之类的C方式给解决，解决发现这一系列API，很实现关于文件截断和文件删除的功能。其实在文件操作中，还有一个POSIX的文件接口方式。比如他的打开文件的函数名为open。 在这里顺便做关于文件操作的一些总结吧。

在window平台其实有至少5种方式访问文件（除去驱动访问，及DDK方式），
1. Windows自己提供的API，比如CreateFile
    功能强大，且因为操作直接，所以效率很高。能满足我这边所有的需求，问题就是不能跨平台。
    所以我拿它做window这边的实现。
2. 标准C的方式，比如fopen
    能跨平台，功能上只是显现基本的文件操作。window平台下，是间接调用Windows API实现功能（比如fopen最终是调用CreateFile）。所以效率稍差，还有文件打开用的属性标记居然用字符串。比如"a+b"。所以到API对应打开的属性需要字符串解析。老实说真不知道当初那些定这个API的人的想法。导致效率又低，且还有功能局限性（有些属性没办法用这些字符串组合实现）。
3. POSIX API，比如open
   UNIX标准接口，window本身也实现了部分。linux也有对于的实现。所以跨平台也还不错。我找了下。塞班也支持，不过支持有限，有些函数和功能还有有些限制。这个系列属于且低级的文件操作，操作效率还可以。且功能强大。所以我打算Iphone上用它去实现。Andriod如果支持的话，也可以考虑用他。
在windows平台是调Windows API实现，调用比较直接几乎没有其他中间层。
4. MFC的CFile类（到vs2003以后是MFC和ATL的共用，不再MFC独有）
   基本上是封装了Windows本身的API，所以功能算是很强大，效率也不错，问题也是不能跨平台。
5. STL的fstream
   因为是个标准，所以在各个平台都有实现，但可能每个平台具体实现会不一样，在window的STL fstream他最终调用的标准C的文件操作类。
   所以他的特性几乎跟C一样，跨平台部分当然要比C方式要差，毕竟某些平台对STL支持不是很好。
   
塞班上：
今天看了3版的接口，貌似POSIX API支持有限，估计不能实现我所有的功能，不过发现有RFile类可以实现大部分的功能。所以打开用它去实现。

二、代码组织
一直以来，我们的为了让代码可以跨平台，许多函数和类里面包含了许多的编译宏，在多个平台下，简直让代码可读性急剧下降。我在这给我一直以来这方面的一些思考。

头文件处理：
如果头文件大部分是一样，那么就简单像以前一样，加几个编译宏处理。
但是如果头文件会有很多不一样，最好在这个头文件中只是在编译宏中，再包含真正的头文件。比如：
在这头文件中写下这样
#ifdefine _win32
   #include "xx_window.h"
#elif __APPLE__
   #include "xx_ios.h"
#else
   #error unsupport system
#end
而最终包含的则是实现需要的。

CPP处理：
这部分也是和头文件基本一样，如果代码部分大部分一样，就像以前那样处理。
如果很多不一样，就直接在cpp 用编译宏，在包含真正实现CPP（C++/C是可以用#include包含Cpp，或者C的）。
不过要注意，耐心哦真正平台的那些CPP，在工程配置中不能做为编译的代码处理。
否则会导致链接错误------>重定义错误
如下：
#ifdefine _win32
   #include "xx_window.cpp"
#elif __APPLE__
   #include "xx_ios.cpp"
#else
   #error unsupport system
#end

而在代码目录我是建议，每个平台单独放一个目录，放其独有的实现。比如头文件

-- xx.h
-- window +
                -- xx_window.h
-- ios        +
                -- xx_ios.h
说白了。工程文件如下： 
第一层文件有 xx.h，文件夹有window和ios
而window文件夹有  xx_window.h
而ios文件夹有 xx_ios.h

这样自我感觉代码目录的结构要清晰很多。

---------------------------------------------------------
10:12 2010-10-8
现在打包的准备工作（如：一些基础框架的研究，压缩算法的选择，及代码的研究）这些都差不多。
现在大致进入代码阶段。以我的风格，一般都会先定义好功能的接口。然后对这些接口进行实现.
而且现在主要工作定义资源文件的结构。说白了，也是文件读写的协议。必须保证兼顾各平台的运行效率及最小内存消耗。
且这块，我觉得资源文件格式以后肯定会版本性的改变。所以在定文件协议的时候，和文件读写的接口时是非常考量的。



---------------------------------------------------------
13:34 2010-10-11
以后新人入职的一些想法，
以前在一家视频公司，入职前是有道门槛的。
首先自己要装系统，做Dos引导ghost备份。
然后熟悉现在的产品，然后做个评价
最后做一个从摄像头读取视频直接播放然后保存成AVI，不过这个是改一个Windows自带东西。

其实觉得这些到是满有价值。因为我们做视频的公司，因为还做板卡，所以硬盘和系统打交道很多，所以必须要熟悉。
其实，了解现有产品那是必须的，对他的评价可以从另一方面得到我们产品的问题。还可以知道他个人对这行的行业了解。
最好莫过于了解这个人的实战能力和抗压力的能力和学习能力了。因为这部分我们给时间很短。虽然说会的很快就能搞定。

以后有机会带人，我觉得也会这样。
首先会让他选研究课题：
最简单就是利用现有的游戏引擎写个 小游戏，比如俄罗斯方块。
最难的过于写 简单的游戏引擎。也可以游戏引擎的某个部分。
比如：声音，网络，Lua引擎(lua语法解析优化就研究)，纯渲染，或者资源管理及虚拟文件系统，
渲染与窗口，纯窗口实现(自绘方式，不一定要适应游戏)，AI
游戏框架,
游戏一些数据算法
游戏公司策划，程序，美术之间的协同想法

跨平台的一些想法。


---------------------------------------------------------
18:18 2010-10-11
一直都想去研究，微软(VS中STL，估计不是微软写的)的那个hashmap的实现。
因为我一直都受困于hash本身不可避免的冲突。
以现在我的理解他应该是一个链表地址发做的，因为我看到他用一个vetor。
这种方法，本身如果遇到冲突还是没有遇到冲突都插进一个链表中，文件查找首先中用hash定位到这个链表。
然后在链表中一个个去比较，那样这样就必须保留原有的hash key，即原始关键字。好比如果原始关键字为一个字符串。
那么他就必须将每个插入的数据的key（字符串）都保存起来，这样做貌似很耗内存，不过平台的map也是要保存的。
还有就是如果hash表不做优化，那么他将以表为大小，在创建hashmap这个数据结构时，创建一个和最大的hash值为大小的表（数组）
这内存将是巨大。比如如果以DWORD为单位。那么他将分配一个1<<32个项，然后每项有个DWORD索引（保存hash）
那么内存为4G×4.那简直是不可能那么做的。


---------------------------------------------------------
17:08 2010-10-15
程序感悟：
好的程序应该写成直线型。不管本身游戏逻辑如何。
很多判断都是可以避免的。那些判断积累之后会很浪费效率。
对于C/C++ 来说， 如果有很多if，swtich这类的判断程序逻辑会很复杂，可读性和出错的概率会增大很多。


---------------------------------------------------------
9:40 2010-10-21
这几天在折腾将刚写好的，打包程序整合到xStar中，本以为无非就是将以前的CPakReader换成我现有的就好了。
在做新的资源包读取的就考虑到移植，就在接口上尽量与前者保持了大体的一致。
结果没想将编译错误解决后，居然发现很多逻辑上的错误，主要还是在我这边资源读取的运行时报错。
现象是：lua经常会传空的资源读取对象给我去读资源，


---------------------------------------------------------
13:52 2010-10-28
面试题:
 有两个排序的队列，找出不同的放进新的
 比如：
  int a[] = {1,2,3};
  int b[] = {2,3,4};

a 比较 b 得出 {1}
b 比较 a 得出 {4}        

如果能实现类型模板方式最好。
 即： T a[] = {1,2,3};
  T b[] = {2,3,4};


---------------------------------------------------------
10:39 2010-11-3
关于模板的问题

模板类的静态 变量，会随有多少实例生成几个。
注意如果全局变量，  模板类访问 他 就跟普通 函数一样。
所以一定要注意，当本想为了只给这个类用，其实作用就是 类似于一个类静态变量，但是为了方便，做写全局。
这样，两个模板类实例 就共同 访问这个全局变量， 有时候就是你 非预期的效果


---------------------------------------------------------
10:54 2010-11-9
  这段时间，一直在折腾资源打包的事情，本来公司这边以前有个打包的，



---------------------------------------------------------
15:29 2010-11-22

关于xStar及其他引擎的整理
1. 将mini stl移到xBase
2. 将xStar的渲染(包括字体，画布，jpg)单独成一个模块，重新定义对外接口
3. 将lua51合成到xBase中，重新定义接口，减去一些非安全的代码
4. 调整原先xStar中的各模块，重新定义接口
5. 模拟器和wce的exe代码重构
6. 优化xStar网络模块
7. 将现有xStar中的hashhelp移到xBase
8. 单实例类  移到xBase
9. 其他？

关于现有打包部分剩余功能
1. mini Game的修改
  ?[] mini game的包是打成最大压缩的，然后再下下来，解一次，还是直接能用的那种
2. 以前有个data2和data， 要合在一起。
3. 程序中那个位置需要加资源包升级的代码
4. FONT转移到FONT中
5. 判断文件是否存在用现有的文件类
6. 读写配置文件，改成写lua代码方式，配置数据需要加密？
7. mota部分读包的部分是否要修改？
8. 平台移植
9. 资源包打开工具


讨论结果
关于现有打包部分剩余功能
1. mini Game的修改
  ?[] mini game的包是打成最大压缩的，然后再下下来，解一次，还是直接能用的那种
2. 以前有个data2和data， 要合在一起。
3. 程序中那个位置需要加资源包升级的代码
//4. FONT转移到FONT中
5. 判断文件是否存在用现有的文件类
//6. 读写配置文件，改成写lua代码方式，配置数据需要加密？
//7. mota部分读包的部分是否要修改？
8. 酷柚裁分包
9. 平台移植
//10. 资源包打开工具


---------------------------------------------------------
16:38 2010-11-22
事情：
1. 讨论定义渲染部分需求，然后定义渲染接口 
2. 讨论 模型碰撞实现方式
3. 地表实现方式
4. 用户操作，按钮界面需求
5. 搭建项目工程（包括代码整理优化）
6. 联调一些功能
7. 上手机调

---------------------------------------------------------
17:37 2010-12-15
最近开始把公司的渲染引擎部分，改成 openGl的方式，现在列列现在自己对这个项目的想法和看法吧
 以我现在的了解主要工作应该在下面几个部分

1. Image部分  基本上，Image部分基本上都实现好了。还剩下一个蒙色，还没有一个 很好的方案，还没有一个直接用openGL实现的方案。
不过，如果最后实现不了，我们可以创建临时在CPU中处理好的图片的方式实现，就是效率差了点就是。

2. 画布， 我本来的想法是直接把这个东西直接的去掉，后面想想，还是留下来吧，这个其实主要还是为了，以后其他平台更好的移植。
   大体做法是，抽象一个 ICanvas接口，然后继承派生出一个系统画布，然后一个临时画布。
   临时画布跟现有画布功能几乎一样，且实现方式也基本上也是一样的。不过这个到是挺麻烦的，因为我最初的想法，Image贴图的类我是不打算去保存图片数据的，因为在图片数据转到OpenGl的材质后，几乎就没什么用处了，特别是以后研究发现蒙色可以处理。但是这个临时画布到给我很大的难道，因为他是CPU把图片数据，贴到一个临时的内存缓存区，那么图片数据必然我是要有的。
  现在逻辑是没有，怎么办？有两个办法：
  a. 没有图片对象保存pakReader对象和图片的名字，当遇到要图片数据的时候，重新从pak包读。你是不是觉得很浪费，一定都不浪费。这两个值肯定不会比图片数据大吧？
  b. 改变原有的逻辑，每个图片对象还是保存图片数据。

3. 图片到xmg的工具。
   因为新Image类，只需要读纯RGB数据，而不需要先这种把RGB数据和Alpha数据分开这种。
   现在这部分已经实现将常见的图片转换为RGB888，RGB8888


有放弃才会没有包袱

---------------------------------------------------------
16:20 2010-12-22
16:23 2010-12-24  update

现在纯OpenGL的引擎已经上路，遇到不少麻烦，我们也是一步步全部解决了。
现在终结下现阶段还有那些事情要做
1. iconv库的移植到Base中
   需要精简里面没有的用字符库。保留原来的接口，用C++封装，类似于我Apple的里面的

2. Font功能
   这部分正在写，主要遇到的问题是
   a. 需要支持A,W两种字符串，以提高效率。需要A->W的转换功能
   b. 字体贴的时候，考虑到三个对齐，其中居中不是很好做，换行符，不做换行处理
   c. 支持Unicode的字体类，需要优化，打算先实现一版每次Draw每次生成材质的
   d. 支持自定义字体的，先不实现了，还没有想好一个很好的实现方案
   e. 在那个FreeType的那个支撑类，好像是按字符创的方式，拼出一个图做为一个材质贴出来，然后缓存固定大小个字符的图

3. Image部分
   a. 实现一个Util的直接贴材质的工具函数，估计会有很多其他的模块会用到，现在Font就需要
   b. 将Blt部分数据改为ushort，以提高效率
   c. [*]貌似材质的区域，以前不是用0.1-1.0 表示贴材质的那些部分。是否可以直接指定他原有的长宽
   d.
   e.

4. 画布部分
   a. 先实现SysCanvas，再考虑实现TmpCanvas
   b. TmpCanvas，印象中是有个临时的context, 或许能解决这个问题，这个不行就用一个材质，纯CPU就算，跑原有的逻辑
   c. 如果存在b中的想法，那么必须实现设置当前的，是那个。
   d. [*]解决画布旋转的问题，主要是指横版机的问题，现在都是每次将图旋转270再贴的。
      很麻烦，看有什么办法实现这个，这样每次贴图就不那么麻烦了
   e.
   f.













































