
----------------------------------------------------------------------
16:19 2011-7-24

  这回真的很多没写日志了，。 说忙，也正的是给自己找借口。
   最近发生了很多事。。xxxx


   还是关心下接着我要做什么？
  
  最近自己的游戏上appstore了， 开始把引擎移植到塞班上。先弄5版。
   其实移植塞班是所有平台难度最大，原先在考虑上根本就去支持CPU算图。所以窗口，渲染这块都是完全依赖openGL做的。
   在接口上，也是完全依赖于openGL，所以改动上，还没具体的计划。
    现在大体想法：
   1. Render： 
           A: 工程部分，弄两个工程，一个老的，一个CPU算图的
           B: src部分， 分opengl1 和 cpu 两个， 以后可以兼容支持opengl2 
           C: inc部分，主要三个地方image，canvas，window
                  1. Image，  接口部分，应该是不需要动。估计大体不需要动
                  2. Canvas， 我原先的定义有部分与openGL绑死了。 如果简单做，就两个办法，在原来的基础上，用宏区别。
                       另一个就是入口一个宏 分别载入到实际的 头文件。 不同情况一个头文件
                  3. window，  这个还在犹豫是否是把它弄到exe里面去，本来这部分本来就是exe里面的
              
   2. 游戏部分
      3版一个目录， 5版一个目录，

   3.  Common，  实现3，5版对于Appcation
   4.  System,   主要声音部分移植



----------------------------------------------------------------------

11:29 2011-10-21
  new start.

  
  国庆回来新的环境，新的开始。
  前段时间，证实5版用openGL es是不行的。 太慢了。 每一帧贴一张全屏的图（360×640）都才5-6帧。
   没办法还是回归到用，CPU渲图的方式。

  当然也只是支持888(1,4,8) 565(1,4,8)。这几种。
  当然优先做，888，8888.在windows把功能先弄出来，然后移植到塞班，如果觉得性能不好再弄565的。


----------------------------------------------------------------------
0:55 2011-10-22
    由于塞班5版需要使用CPU渲图，那么必要有个新功能必做。
  那就是  图片旋转部分。 这部分不可能再实际贴图的生成旋转的图，然后再贴。
  因为那样显然会慢很多。
  有一种做法是，新一个API，lua指定哪些图预先生成固定个图（平均某个角度生成一张），lua传过来的度数，取一个最近的图，然后贴。 还有一种中折的方案，就是在旋转贴的时候，如果发现某个角度的图（也是固定张图，每个固定角度一张）图没有生成就生成一张，然后保存起来，下一次贴的这个角度就用保存起来的那个。

  当然，两张方案各有各的好处，不过不管采用哪种。都避免不了一个问题。生成的旋转的图的数据的 在内存的存放格式，也就是数据结构。

  做法1：
也是最常规的做法，就是一张旋转的图的最大矩形，把图放在这个矩形里面。没有图数据的地方都是Alpha为0.但是这个就有一个问题。
  如果是一张888或者565的图，他本身没有alpha，那么得生成一个带alpha的图。不过生成的是一个点实的图，也就是alpha只有0和1.这个必然会造成数据量很大，当然最大的优势就是剩下的旋转之后的与背景的图之间做运算就理解成普通的图之间的混合就好了。功能可以直接调blt。
优点：生成的旋转图与背景混合不要重新写代码。
缺点：数据量大，图的混合效率差（数据量和有时候会出现alpha）

  做法2：
  是我刚在洗澡的时候想到的。
  选算出图旋转之后的高。然后又一个该高的数组，
strct { ushort pos; ushort num;} a [h];
  类似于int a[h].
  然后new 一个原图一样的大的buf。用于存放新计算出的旋转的图。
 注： 这个地方有可能，新图需要的buf大于或者小于原图的数据，因为在计算时候，有四舍五入的情况。当然按道理基本等于原图的大小，就算有差别估计最大的偏差大概为新的高那么多。
  a[h], h表示某行的信息。 pos为buf的位置，num为该行有多少个像数。
然后混合就这样循环：
 for(i=0;i<h;++i)
   for(j=0;j<a[0].num;++j)
 ---   可能实际的渲染的时候 pos 没有多大的用处。
 
  而buf存放原图数据的方式为，一行的存，存完上一行就接着存一行。
  其实也可以存完一行后，放一个标志位代表改行结束。不过这个有个可行性的问题，就是这个标志为用啥。因为颜色数组几乎可以用所有种数据，比如565的数据，肯定如果一个ushort所有的可能都会有。不过你可以多判断几位，从而减少出现颜色数据和标志重合的概率。或者标志位为动态的，扫描全部像素如果存在某个就换另外一个标志位。这种做法的好处是，不需要a[h]这个东西。但是会带来贴图不灵活的问题和图混合算法教复杂的问题。




----------------------------------------------------------------------
11:01 2011-11-17

昨天把RGB8888 和 RGB888的代码终于弄完了，这个部分牵涉算法的地方太多，太耗时间了。导致花了那么多时间。
现在这个部分还有以下几个部分感觉还没弄完或者没弄好。

1. 旋转没有做优化，
  1.1 弄成我上面写的数据结构来加快渲染和减少内存，
  1.2 没有将旋转出来的图保存起来，用以下次渲染
2. 565 系列的图没做
3. 旋转和缩放代码还做足够的优化，和做足够的注释
4. 塞班的系统画布，还没有直接用系统的那片内存。从而减少内存消耗和减少每一帧一次大内存拷贝
[x]5. 字体没弄
[]6. 声音没有移植进来
7. 画线画矩形没弄


----------------------------------------------------------------------
17:13 2011-11-17
1. 刚才在解决字体在Raw模式显示的问题的时候，发现蒙色有点问题。
 本来还以为是 gles本身就有问题，后来自己仔细研究了两边的代码，居然发现raw里面的蒙色算法有问题。
 还好幸亏移植了font，才知道这个bug，不然要拖到什么时候才知道。



10:59 2011-11-25
 首先总结下最近的工作。
    1. 把重力感应和妹子结合，感觉还行吧。没有但是飞机那么夸张
    2. 把邹的声音代码移植进了引擎。移植过程发现mp3如果设置成 单声道文件大小貌似没什么变化。不过把采样调小(22050)体积基本少了一半。
       wav（pcm数据）改单声道体积就一半，采样改为22050，也少一半。  
     [] 以后可以试试 把声音的比特改为8试试，或许还能少一半， 不过就是不知道效果会这样。

接下来的工作：
   1. 写一个线程库，包括相关的信号量之类的（这个以后慢慢补充）
   2. 把声音移植进apple和塞班
   3. 将system取消掉，把原有的 SysFun放在exe的里面， 声音单独放在Audio这个新的模块里面


----------------------------------------------------------------------
15:16 2011-11-28


开始写Thread库， 一直以来不知道是自己懒还是觉得自己觉得了解的不够。所以一直都没下手。
好吧， 鼓起勇气弄吧，， 弄完这个还要写一个时间的库，毕竟这个也是肯定会用的。



----------------------------------------------------------------------
17:49 2011-12-8

今天把ios上的声音弄出来，原本以为会听罗嗦，当然也遇到不少问题，弄了半天。结果换下资源就好了。
而且ios上根本就不需要额外开一个线程，搞得我折腾了线程挺久的。

 这段时间也一直在写一个线程库，看了不少unix下posix不少资料。虽然自己弄的这个简单的线程库，自己是觉得很满意，当然也存在很多需要补充的地方。但是从中也体会到unix一些系统上的东西。unix真的跟window区别真的很大。从线程进程这个概念上讲，unix从设计开始就以多进程的方式提升程序的效率。而没想到去用线程去做，可能跟unix但是的环境有关吧，但是硬件比较差，操作系统的概念也比较早。所以我想才会这样吧。而window跟unix相比从年纪上讲本身就是一个小弟弟，毕竟晚了那么多年。从windows的API我也发现不上unix的影子。所以我觉得windows在设计时倒是借鉴unix不少东西。程序嘛。如果要做一样东西，如果这个世界有，干嘛不先看看别人是怎么做，吸取别人的优点，尽量避免其的缺点。好吧，还是说说windows他自己吧，他原生设计就是按线程做，所以他的线程的API也是异常强大。不仅这样，根据网上的说法，windows的线程也比unix的性能好不少，或者unix内核比较发展会慢慢赶上，当然unix在进程上就有他的优势，api的功能的确比window强大。fork这个功能就是window没有的。

  在学习unix线程的时候，顺便看了下一个开源的跨平台的线程库。比如boost的线程库。zthread。POCO（由于同时想弄网络这块）。这些库，boost可最骚包了，我大体参考了他的一些函数接口。毕竟这个是以后C++的标准库。 不过我真不喜欢他的这些接口和实现。倒是很喜欢zthread的风格。而且我打算把现在写的这个thread库，改成他这个方式，他的大体实现是这样的，首先对外的接口，很简单。 关键他的成员变量就一个就是每个平台真正实现对应功能的类，而且这个变量有了指针，那么他就只需要在头文件定义是一个类就好了。然后再具体cpp里面也写的相当简单，直接掉实现的类对应函数就好了。然后在实现的类里面对应每个平台做。 这个方式唯一的缺点就是要new一个那个实现的类，如果针对那些不需要new很多个那些功能这个几乎可以忽略不计。不过thread的确就是这样，整个程序不可能有很多个线程类吧。有的话，那是多大的程序。


14:17 2011-12-26
----------------------------------------------------------------------

 今天在看 引擎编译时，报了不少 把一个int数据赋值给float的错误。
  所以就想了想了为什么？ 按常规其实float能表达的数据要比int大很多，但是为什么又会报错了？
   
 。。 文档看的太难受了。。。


----------------------------------------------------------------------
10:34 2012-1-9
  线程切换，系统做了那些工作，
比如：保留上一个线程的现场，好下次继续，


----------------------------------------------------------------------
12:06 2012-2-2
开始弄android了。

昨天把SDK+NDK环境搭好。
所以基本的NDK调用已经OK了/

所以现在思路是这样。。
1. 用NDK实现一个 渲染的东西
2.  看纯C方式可行不？
3. 多dll的方式，还是一个DLL。


----------------------------------------------------------------------
12:21 2012-2-9

  @idea:
    做一个应用， 形式类似于一个游戏大厅。
    大厅主UI，就像iphone的主UI， 上面4×4的按钮图，下面一个固定的按钮图，
    固定按钮可以这些
	1.游戏商城，= AppStore， 在iphone上可以用 内置付费的方式，购买新的应用。也可以下免费的
        2.用户登录，退出，更改用户登录
	3.各成就及积分，排名
	4.好友聊天之类
    4×4区域：
        1.各游戏，游戏可以用iphone的方式，按住不动就卸载，主ui可以像iphone一样左右拖动，需要注意的是，当开启多个游戏时，需要提示用户，可能会由于开启多个游戏造成内存不足，
    本身，由于我们游戏lua的实现，那么我们就可以方便的下载新的游戏，
     

----------------------------------------------------------------------
11:38 2012-2-28
前几天把Android的部分移植的7788了。 现在功能上只要是声音部分，还有就是临时画布部分。
现在基本是Android 2.3， 因为现在的引擎是纯C++开发。 还有以后声音部分还是在2.3之后才开放C的API

现在开始弄服务端。


----------------------------------------------------------------------
19:47 2012-2-28
@idea:
 下午在移植性lua到服务端的时候，发现lua也出了弄了很久的5.2，正在纠结到底是用5.1还是5.2的时候，
  突然想到lua调式的问题，我想干嘛不在服务端直接内嵌lua的调式的IDE， 比如我们原先服务器是，中间大部分都是一个RichEdit来查看lua弄出来的log，当然log为了让游戏逻辑的编写者，看的舒服，我们log。warm error都是用不同颜色标识的。那么我们为什么不在那个地方，弄一个tab，tab的一项是那个RichEdit，另外一个是调式lua的IDE， 里面可以有下拉框去打开某个lua文件，然后在左边像VC一样可以点击断点。 上面放单步之类的按钮，这样以后开发lua岂不是很简单。


----------------------------------------------------------------------
11:41 2012-3-2
   最近先弄 Font， 描边+像素偏移问题


----------------------------------------------------------------------
10:43 2012-3-13
昨天把Font的一些东西弄完了。
 1. 描边， 稍微研究了下，后来还是没做， FreeType还是很复杂，按网上的说法肯定是可以做的，但是网上的资料也压根不能做到描边。都说的很模糊

 2. Font openGL渲染加速问题，
    发现用glDrawArray 也可以实现这个功能，原先是想用glDrawElement的。网上都是用这个。
    本来打算用 glDrawArray + glBufferData, 但是想了想， 其实应该差不多性能，因为都是一次性向显卡输入材质的坐标点。
    我觉得如果是材质的坐标点不变化，的确用glBufferData要快，
    [] glDrawElement 到底用在那些实际的应用里

  3. 根据一个字符串，通过Freetype 的位图，生成一个该字符串的材质。
  4. 因为Freetype生成的图是Alpha图，所以用材质也是Alpha图是最好的，在内存和代码实现（简单）的上都是最好。
     但是在做的时候，遇到一个问题，折腾了我好久， 就是在 材质更新时，数据就不对了。
     后来发现要在 初始化里面加个这个，  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);大概是说像素对齐的方式把。


























