
----------------------------------------------------------------------
16:19 2011-7-24

  这回真的很多没写日志了，。 说忙，也正的是给自己找借口。
   最近发生了很多事。。xxxx


   还是关心下接着我要做什么？
  
  最近自己的游戏上appstore了， 开始把引擎移植到塞班上。先弄5版。
   其实移植塞班是所有平台难度最大，原先在考虑上根本就去支持CPU算图。所以窗口，渲染这块都是完全依赖openGL做的。
   在接口上，也是完全依赖于openGL，所以改动上，还没具体的计划。
    现在大体想法：
   1. Render： 
           A: 工程部分，弄两个工程，一个老的，一个CPU算图的
           B: src部分， 分opengl1 和 cpu 两个， 以后可以兼容支持opengl2 
           C: inc部分，主要三个地方image，canvas，window
                  1. Image，  接口部分，应该是不需要动。估计大体不需要动
                  2. Canvas， 我原先的定义有部分与openGL绑死了。 如果简单做，就两个办法，在原来的基础上，用宏区别。
                       另一个就是入口一个宏 分别载入到实际的 头文件。 不同情况一个头文件
                  3. window，  这个还在犹豫是否是把它弄到exe里面去，本来这部分本来就是exe里面的
              
   2. 游戏部分
      3版一个目录， 5版一个目录，

   3.  Common，  实现3，5版对于Appcation
   4.  System,   主要声音部分移植



----------------------------------------------------------------------

11:29 2011-10-21
  new start.

  
  国庆回来新的环境，新的开始。
  前段时间，证实5版用openGL es是不行的。 太慢了。 每一帧贴一张全屏的图（360×640）都才5-6帧。
   没办法还是回归到用，CPU渲图的方式。

  当然也只是支持888(1,4,8) 565(1,4,8)。这几种。
  当然优先做，888，8888.在windows把功能先弄出来，然后移植到塞班，如果觉得性能不好再弄565的。


----------------------------------------------------------------------
0:55 2011-10-22
    由于塞班5版需要使用CPU渲图，那么必要有个新功能必做。
  那就是  图片旋转部分。 这部分不可能再实际贴图的生成旋转的图，然后再贴。
  因为那样显然会慢很多。
  有一种做法是，新一个API，lua指定哪些图预先生成固定个图（平均某个角度生成一张），lua传过来的度数，取一个最近的图，然后贴。 还有一种中折的方案，就是在旋转贴的时候，如果发现某个角度的图（也是固定张图，每个固定角度一张）图没有生成就生成一张，然后保存起来，下一次贴的这个角度就用保存起来的那个。

  当然，两张方案各有各的好处，不过不管采用哪种。都避免不了一个问题。生成的旋转的图的数据的 在内存的存放格式，也就是数据结构。

  做法1：
也是最常规的做法，就是一张旋转的图的最大矩形，把图放在这个矩形里面。没有图数据的地方都是Alpha为0.但是这个就有一个问题。
  如果是一张888或者565的图，他本身没有alpha，那么得生成一个带alpha的图。不过生成的是一个点实的图，也就是alpha只有0和1.这个必然会造成数据量很大，当然最大的优势就是剩下的旋转之后的与背景的图之间做运算就理解成普通的图之间的混合就好了。功能可以直接调blt。
优点：生成的旋转图与背景混合不要重新写代码。
缺点：数据量大，图的混合效率差（数据量和有时候会出现alpha）

  做法2：
  是我刚在洗澡的时候想到的。
  选算出图旋转之后的高。然后又一个该高的数组，
strct { ushort pos; ushort num;} a [h];
  类似于int a[h].
  然后new 一个原图一样的大的buf。用于存放新计算出的旋转的图。
 注： 这个地方有可能，新图需要的buf大于或者小于原图的数据，因为在计算时候，有四舍五入的情况。当然按道理基本等于原图的大小，就算有差别估计最大的偏差大概为新的高那么多。
  a[h], h表示某行的信息。 pos为buf的位置，num为该行有多少个像数。
然后混合就这样循环：
 for(i=0;i<h;++i)
   for(j=0;j<a[0].num;++j)
 ---   可能实际的渲染的时候 pos 没有多大的用处。
 
  而buf存放原图数据的方式为，一行的存，存完上一行就接着存一行。
  其实也可以存完一行后，放一个标志位代表改行结束。不过这个有个可行性的问题，就是这个标志为用啥。因为颜色数组几乎可以用所有种数据，比如565的数据，肯定如果一个ushort所有的可能都会有。不过你可以多判断几位，从而减少出现颜色数据和标志重合的概率。或者标志位为动态的，扫描全部像素如果存在某个就换另外一个标志位。这种做法的好处是，不需要a[h]这个东西。但是会带来贴图不灵活的问题和图混合算法教复杂的问题。




----------------------------------------------------------------------
11:01 2011-11-17

昨天把RGB8888 和 RGB888的代码终于弄完了，这个部分牵涉算法的地方太多，太耗时间了。导致花了那么多时间。
现在这个部分还有以下几个部分感觉还没弄完或者没弄好。

1. 旋转没有做优化，
  1.1 弄成我上面写的数据结构来加快渲染和减少内存，
  1.2 没有将旋转出来的图保存起来，用以下次渲染
2. 565 系列的图没做
3. 旋转和缩放代码还做足够的优化，和做足够的注释
4. 塞班的系统画布，还没有直接用系统的那片内存。从而减少内存消耗和减少每一帧一次大内存拷贝
5. 字体没弄
6. 声音没有移植进来
7. 画线画矩形没弄


----------------------------------------------------------------------
17:13 2011-11-17
1. 刚才在解决字体在Raw模式显示的问题的时候，发现蒙色有点问题。
 本来还以为是 gles本身就有问题，后来自己仔细研究了两边的代码，居然发现raw里面的蒙色算法有问题。
 还好幸亏移植了font，才知道这个bug，不然要拖到什么时候才知道。




























