-

----------------------------------------------------------------------
10:34 2012-1-9
  线程切换，系统做了那些工作，
比如：保留上一个线程的现场，好下次继续，


----------------------------------------------------------------------
12:06 2012-2-2
开始弄android了。

昨天把SDK+NDK环境搭好。
所以基本的NDK调用已经OK了/

所以现在思路是这样。。
1. 用NDK实现一个 渲染的东西
2.  看纯C方式可行不？
3. 多dll的方式，还是一个DLL。


----------------------------------------------------------------------
12:21 2012-2-9

  @idea:
    做一个应用， 形式类似于一个游戏大厅。
    大厅主UI，就像iphone的主UI， 上面4×4的按钮图，下面一个固定的按钮图，
    固定按钮可以这些
	1.游戏商城，= AppStore， 在iphone上可以用 内置付费的方式，购买新的应用。也可以下免费的
        2.用户登录，退出，更改用户登录
	3.各成就及积分，排名
	4.好友聊天之类
    4×4区域：
        1.各游戏，游戏可以用iphone的方式，按住不动就卸载，主ui可以像iphone一样左右拖动，需要注意的是，当开启多个游戏时，需要提示用户，可能会由于开启多个游戏造成内存不足，
    本身，由于我们游戏lua的实现，那么我们就可以方便的下载新的游戏，
     

----------------------------------------------------------------------
11:38 2012-2-28
前几天把Android的部分移植的7788了。 现在功能上只要是声音部分，还有就是临时画布部分。
现在基本是Android 2.3， 因为现在的引擎是纯C++开发。 还有以后声音部分还是在2.3之后才开放C的API

现在开始弄服务端。


----------------------------------------------------------------------
19:47 2012-2-28
@idea:
 下午在移植性lua到服务端的时候，发现lua也出了弄了很久的5.2，正在纠结到底是用5.1还是5.2的时候，
  突然想到lua调式的问题，我想干嘛不在服务端直接内嵌lua的调式的IDE， 比如我们原先服务器是，中间大部分都是一个RichEdit来查看lua弄出来的log，当然log为了让游戏逻辑的编写者，看的舒服，我们log。warm error都是用不同颜色标识的。那么我们为什么不在那个地方，弄一个tab，tab的一项是那个RichEdit，另外一个是调式lua的IDE， 里面可以有下拉框去打开某个lua文件，然后在左边像VC一样可以点击断点。 上面放单步之类的按钮，这样以后开发lua岂不是很简单。


----------------------------------------------------------------------
11:41 2012-3-2
   最近先弄 Font， 描边+像素偏移问题


----------------------------------------------------------------------
10:43 2012-3-13
昨天把Font的一些东西弄完了。
 1. 描边， 稍微研究了下，后来还是没做， FreeType还是很复杂，按网上的说法肯定是可以做的，但是网上的资料也压根不能做到描边。都说的很模糊

 2. Font openGL渲染加速问题，
    发现用glDrawArray 也可以实现这个功能，原先是想用glDrawElement的。网上都是用这个。
    本来打算用 glDrawArray + glBufferData, 但是想了想， 其实应该差不多性能，因为都是一次性向显卡输入材质的坐标点。
    我觉得如果是材质的坐标点不变化，的确用glBufferData要快，
    [] glDrawElement 到底用在那些实际的应用里

  3. 根据一个字符串，通过Freetype 的位图，生成一个该字符串的材质。
  4. 因为Freetype生成的图是Alpha图，所以用材质也是Alpha图是最好的，在内存和代码实现（简单）的上都是最好。
     但是在做的时候，遇到一个问题，折腾了我好久， 就是在 材质更新时，数据就不对了。
     后来发现要在 初始化里面加个这个，  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);大概是说像素对齐的方式把。

----------------------------------------------------------------------
12:20 2012-3-19
 []关于服务重连的问题，服务端需要处理下，
    问题如下：
    比如C为客户端， S为服务端。 
    1. C 发一个请求（假如代号为1）给S，
    2. S收到数据， 这个时候C与S的连接由于某种原因断开（可能超时或者其他的）。
       这个时候，S一般都会先处理1，处理完1后，发现与C断开了，这个时候S一般会丢掉1的数据，
    3. 这个时候C又发1上来（重连），S又处理一次1，导致数据不对。

     一个典型的例子就是， 商城买东西，点一下结果买了2个东西。

    如何解决：
    C发请求的时候，带一个ID，表示是那个请求，然后S发现掉线先保留1的数据，然后C如果再发同一个ID的数据，直接返回上一次的数据。
   所以在流程上必须要求，C第一次请求最好是上次重连的那个，而且ID不能变。
   第二个就是，S要做超时处理（或者其他的方式），将保留的1的数据清掉，因为这个也很有可能是客户端退出发的请求，那么C可能很长一段时间不会再连接。如果多个客户端出现这个情况势必会浪费服务端内存。

----------------------------------------------------------------------
15:12 2012-6-4
Engine 1.3 添加的功能
[] 1.框架小的调整
[] 2.Android 完善
   []2.1 按键消息处理
   []2.2 程序收尾
   []2.3 声音
   []2.4 输入法
   []2.5 网络功能
[] 3.ios 完善
   []3.1 网络功能验证
   []3.2 输入法
[] 4 FreeType，字体文件，研究是否可以使用系统的
[] 5.PC 输入法
 

---------------------------------------------------------------------- 
16:30 2012-6-4
 对lua改动的API如下：

大的框架：
1. C++对象创建与释放
   1.1 凡是以xNew开头的，意味lua必须手动去释放，调用xDelete，或者xDeletes
     ex1: 假如有一个xNew开头的创建出来的对象obj，释放为xDelete(obj)
     ex2: 假如有两个xNew开头的创建出来的对象obj1，obj2, 要一次释放多个，释放为xDeletes(2,obj2,obj2)
   1.2.凡是以xCreate开头创建的对象，这个对象释放必然有个专门的释放函数。
     ex: 如果创建函数为xCreateXXX，释放的函数一般为xDestroyXXX，对象为obj。那么xDestroyXXX(obj)

2. 淡入淡出去掉
3. lua加载，是否是 包模式还是裸的， 又引擎处理
4. 引擎主动调用的lua函数，以lua开头

去掉如下
1.淡入淡出，各种Fade
2.SysFunc 及对应的消息 ESendToBackground EGetScreenSize EGetMachineUid
    EResetOffscreen ESwitchInput， 对应的功能将有新的API代替
3.ResetCanvas, 原意是重置系统画布，这个不好实现，且实用不高
4.SysFunc，，已无用
5. lua全局变量sGame,已无用
6. KLuaDebug  ,已无用
7. APP_PATH 去掉， 以后所有跟路径相关的API都不需要这样-->（APP_PATH.."sound.pak"），直接文件名就可以. 这个目的有下列原因：
     a. 省去lua 调用某些带路径的API的麻烦
     b. 直接写文件名比较好在不同平台的处理， 比如ios， 其实资源包本来是在程序包里面，为了兼容路径模式。ios程序在首次运行就得从程序包拷贝一份到 ios一个可写的目录。
8. xDelPakReader，xReleaseR，xReleaseRs，xBFile_Close  直接用xDelete/xDeletes
9. xMapDel, xAnimDel  直接用xDelete
10. xLoadLuaFile_Android ,已无用 
11. 引擎主动调用的lua函数
    // 框架函数
    InitMain    -> luaMain  
    MainRelease -> luaExit
    MainUpdate  -> luaUpdate
    MainDraw    -> luaDraw

    // 事件函数， 具体参数参考引擎里面的代码
    EventForeground  -> luaEvtWindowShow
    EventKey         -> luaEvtKey
    EventTouch       -> luaEvtTouch
12.


增加如下
1.ShowIme HideIme ，代替原来SysFunc ESwitchInput
2.

改动：
1.所有的引擎直接设置给lua的全局变量都是以全大写，单词下划线分隔， 比如， LUA_OS
1.lua得到系统画布，由原来引擎直接设置一个全局变量变为 一个新API获取
2.lua得到系统画布宽高。 由原来的全局变量(SYS_W, SYS_H)， 变为新API获取
3. sCanvas, 改为
4. xXLOG， --> xLog, 这个在debug，还是release都有
5. xMapNew --> xNewMap  xAnimNew --> xNewAnim
6. xBFile_OpenByRead --> xNewBFileByRead  xBFile_OpenByWrite --> xNewBFileByWrite
7. KSC_SELECT_LEFT 等之类， 改为 KB_SELECT_LEFT KSC->KB
   按键类型现在就支持 
      KB_SELECT_LEFT  KB_SELECT_RIGHT  KB_SELECT_OK
      KB_ARROW_UP  KB_ARROW_DOWN KB_ARROW_LEFT KB_ARROW_RIGHT

----------------------------------------------------------------------
17:03 2012-6-7
  关于客户端资源更新问题。
  以前的做法是，服务端做一个比较的更新包， 客户端得到更新包后， 删除老的包里面没用的，然后将的数据和老的包的数据整合在一起，放在一个新的文件。然后删除老的包，然后将新的文件重新命名为 老的包的名字。
   这样做的好处是： 
   a. 客户端调用更新完的包还是以前同样的逻辑，
   b. 用户的硬盘占用最小。但有峰值。
   缺点：
   a. 更新的速度慢，比较耗CPU，
   b. 象ios和android这种， 资源包本身在程序包里面。处理起来有很多问题。ios和android就必须先拷贝出来， 那么其实是占用用户的磁盘空间，还有就是象android可以清这些数据，所以处理起来会很麻烦。
   c

   新的做法：
   pak包，文件头有个标志位，表示是一个包的文件(也就是原有pak逻辑)，还是支持更新叠加，多文件

   多文件加载流程：
    首先但pakReader发现该文件支持多文件，那么首先去读系统配置表，如果发现配置表不存在就创建一个默认的，如果有配置表，就读还有那些文件，这些文件是带时间顺序的， 然后将原版包 索引数据读出，放进 map表，然后依次读 增量包， 增量包文件包头有个属性代表他是增量包，增量有个数据段代表以前的那些数据废了，然后就是新增的。 更新索引的map表， map的索引表必然要带 pakReader的句柄，然后就是文件的位置。
   如果有新的更新包过来，首先下载（先不具体下载逻辑），下载成功后，更新系统配置表，插入一个新更新包。

   异常处理（不考虑网络下载失败之类问题）：
    1. 想android这种，用户清掉数据，导致更新包全部丢失，那么文件打开时需要向服务器重新下载该更新包，或者直接提示用户说，数据损坏，请重新安装。
    2. 更新的时候，用户切后台导致一些问题，这个主要跟网络下载有关。

   好处：
    1.更新快， 纯下载时间。
    2.原始包可以保留
   缺点：
    1.当更新包很多时，会有很多冗余数据，毕竟有那么多要删除的数据，
    2.需要写两个大的模块， 资源包读取逻辑大部分需要重写。 需要写一个更新包打包器   
   

----------------------------------------------------------------------
10:17 2012-6-25
上周工作内容
客户端引擎：
1.IOS主体框架调整（x）
2.IOS输入法功能（实现核心功能，现在卡在输入法弹入弹出实现动画效果上）
3.IOS Http，（delay，计划没考虑周五放假）


策划：



服务端：
以后叫邹国城说这个事，现在基本已经交给他负责。


----------------------------------------------------------------------
13:47 2012-7-2
  1. 关于C函数不定参数的问题， 引擎的一个代码用到，不定参数，
     其中有个是va_arg(arpg, float)。然后在xcode编译发现是错误的， 于是仔细看真没发现什么问题， 没办法就问google，  发现不定参数还有那么一套东西。
   ``参数默认晋级" 规则适用于在可变参数中的可变动部分: 参数类型为 float 的总是晋级 (扩展) 到 double, char 和 short int 晋级到 int。
   也就是你在输入不定参数函数的值时， 如果你输入一个float，那么会自动转换为double push进栈。

  2. android上遇到的一个问题。 编译时，提示有个链接错误，就是常见的某个链接的定义为找到。一般的来说都是lib库没有link。 后来调式折腾才知道。 对于make而言，一个静态库需要另外一个静态库需要指定那个lib， 在我印象中，vc是不要的。


13:55 2012-7-2
----------------------------------------------------------------------

   















