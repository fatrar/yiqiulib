

----------------------------------------------------------------------
10:34 2012-1-9
  线程切换，系统做了那些工作，
比如：保留上一个线程的现场，好下次继续，


----------------------------------------------------------------------
12:06 2012-2-2
开始弄android了。

昨天把SDK+NDK环境搭好。
所以基本的NDK调用已经OK了/

所以现在思路是这样。。
1. 用NDK实现一个 渲染的东西
2.  看纯C方式可行不？
3. 多dll的方式，还是一个DLL。


----------------------------------------------------------------------
12:21 2012-2-9

  @idea:
    做一个应用， 形式类似于一个游戏大厅。
    大厅主UI，就像iphone的主UI， 上面4×4的按钮图，下面一个固定的按钮图，
    固定按钮可以这些
	1.游戏商城，= AppStore， 在iphone上可以用 内置付费的方式，购买新的应用。也可以下免费的
        2.用户登录，退出，更改用户登录
	3.各成就及积分，排名
	4.好友聊天之类
    4×4区域：
        1.各游戏，游戏可以用iphone的方式，按住不动就卸载，主ui可以像iphone一样左右拖动，需要注意的是，当开启多个游戏时，需要提示用户，可能会由于开启多个游戏造成内存不足，
    本身，由于我们游戏lua的实现，那么我们就可以方便的下载新的游戏，
     

----------------------------------------------------------------------
11:38 2012-2-28
前几天把Android的部分移植的7788了。 现在功能上只要是声音部分，还有就是临时画布部分。
现在基本是Android 2.3， 因为现在的引擎是纯C++开发。 还有以后声音部分还是在2.3之后才开放C的API

现在开始弄服务端。


----------------------------------------------------------------------
19:47 2012-2-28
@idea:
 下午在移植性lua到服务端的时候，发现lua也出了弄了很久的5.2，正在纠结到底是用5.1还是5.2的时候，
  突然想到lua调式的问题，我想干嘛不在服务端直接内嵌lua的调式的IDE， 比如我们原先服务器是，中间大部分都是一个RichEdit来查看lua弄出来的log，当然log为了让游戏逻辑的编写者，看的舒服，我们log。warm error都是用不同颜色标识的。那么我们为什么不在那个地方，弄一个tab，tab的一项是那个RichEdit，另外一个是调式lua的IDE， 里面可以有下拉框去打开某个lua文件，然后在左边像VC一样可以点击断点。 上面放单步之类的按钮，这样以后开发lua岂不是很简单。


----------------------------------------------------------------------
11:41 2012-3-2
   最近先弄 Font， 描边+像素偏移问题


----------------------------------------------------------------------
10:43 2012-3-13
昨天把Font的一些东西弄完了。
 1. 描边， 稍微研究了下，后来还是没做， FreeType还是很复杂，按网上的说法肯定是可以做的，但是网上的资料也压根不能做到描边。都说的很模糊

 2. Font openGL渲染加速问题，
    发现用glDrawArray 也可以实现这个功能，原先是想用glDrawElement的。网上都是用这个。
    本来打算用 glDrawArray + glBufferData, 但是想了想， 其实应该差不多性能，因为都是一次性向显卡输入材质的坐标点。
    我觉得如果是材质的坐标点不变化，的确用glBufferData要快，
    [] glDrawElement 到底用在那些实际的应用里

  3. 根据一个字符串，通过Freetype 的位图，生成一个该字符串的材质。
  4. 因为Freetype生成的图是Alpha图，所以用材质也是Alpha图是最好的，在内存和代码实现（简单）的上都是最好。
     但是在做的时候，遇到一个问题，折腾了我好久， 就是在 材质更新时，数据就不对了。
     后来发现要在 初始化里面加个这个，  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);大概是说像素对齐的方式把。

----------------------------------------------------------------------
12:20 2012-3-19
 []关于服务重连的问题，服务端需要处理下，
    问题如下：
    比如C为客户端， S为服务端。 
    1. C 发一个请求（假如代号为1）给S，
    2. S收到数据， 这个时候C与S的连接由于某种原因断开（可能超时或者其他的）。
       这个时候，S一般都会先处理1，处理完1后，发现与C断开了，这个时候S一般会丢掉1的数据，
    3. 这个时候C又发1上来（重连），S又处理一次1，导致数据不对。

     一个典型的例子就是， 商城买东西，点一下结果买了2个东西。

    如何解决：
    C发请求的时候，带一个ID，表示是那个请求，然后S发现掉线先保留1的数据，然后C如果再发同一个ID的数据，直接返回上一次的数据。
   所以在流程上必须要求，C第一次请求最好是上次重连的那个，而且ID不能变。
   第二个就是，S要做超时处理（或者其他的方式），将保留的1的数据清掉，因为这个也很有可能是客户端退出发的请求，那么C可能很长一段时间不会再连接。如果多个客户端出现这个情况势必会浪费服务端内存。




  
