



-----------------------------------------------------------

2010-01-06
感谢，感恩他们。
今天开画IV的概要设计的活动图，画了我1个小时，才把Powerdesign的工程配置好。
突然想起今天自己，设计也慢慢感到自然，回想当年刚来深圳，真是空白。
想起自己这短短的在深圳的人生中，我把自己这张混乱的白纸，真不知道将要画成什么样。
在这几年，看到自己现在的不大不小的成就，我不得不，要感谢他们，他们给我源泉。
刚来深圳的时候，东哥教会了我写代码。有了他我现在的代码规范和代码能力和技巧。虽然他是那么的严厉，也曾经有那么多次的合作不愉快，但是还是非常感谢他。第二个要感谢的是张程鹏，因为他，让我接触到了什么设计，为我注入了新的力量。虽然那个时候是那么的渺小，合作时间也就那么短。第三个要感谢的是道旭和道旭的廖经理，因为他或者它，让我去更好的实现的自己想法，更多让自己去实战很多很多。才不会让自己自有空有的想法而没有实际。在那里代码能力得到了充足展现，设计水平也得到比较的深入理解。 感谢他们，虽然自己还没达到很高的角度的回顾。但是以后我一定会的。


-----------------------------------------------------------


9:13 2010-1-8
关于当初对界面的想法
以现在的资料游戏的方式是 
CEGUI做界面引擎       -- 提供基本的界面编辑接口
OGRE做3D/2D渲染引擎   -- CEGUI会调用它用以实际的显示
Lua做界面编写语言     -- 脚本语言动作做需要的不同控件，首先用lua做基础控件，比如对话框，listctrl， 等


今天在ATLBase.h发现几个以前要写的类，不过有写以前就写了。现在列出来。、
CHandle
CCritSecLock
CAutoStackPtr
CAutoPtr
CAutoVectorPtr
CComCritSecLock


-----------------------------------------------------------
11:56 2010-1-13
几天打算正式写智能的代码，按我的习惯我会首先将工程全部建立好，然后将代码慢慢的补全。
结果老是出现一些预编译的问题，pdb文件有问题啊，不存在啊。。 真是郁闷，
结果重新建了VC6的工程，然后用2005去转换又没事了。我好象那个以前的工程没做很复杂的设置啊。
不明白。。。不过他用Create Precompiled Header 又没事。 Use死活就是不行。我就纳闷了，Use还是工程默认设置，怎么会这样， 
我想啊。。 我改成2005不就设置了下inlcude。因为我想把接口文件放include目录下，代码放在Src，
其实我自己也没搞清楚，到底为什么这么做。 或许是SVN的原因，他只能指定某个目录的权限，这样做好管理吧。 include里面集中放接口可以提高速度，其他的我就想不起作用了。。。。


-----------------------------------------------------------
15:52 2010-2-1

今天突然想起怎么去提高写代码的速度，

其实个人觉得每个人如果光靠打字速度去发展的话，那么那个个肯定是写的最慢。
在我这几年写代码的经验中，整个代码如果顺利的话写完其实是很快，不过就是往往不顺利
（如功能的变化、因为写剩下的功能时，发现以前写的有冲突或者很丑陋），导致代码的重构，然后这个过程的修修改改浪费了我们写代码的绝大数的时间，所以在写代码前思考好，写的代码也应该有足够的弹性，这样会大大减少未来和现在重构带来的代价。

那么如果让自己的代码写的有弹性呢？
1.针对接口编程
2.实现的函数尽量写的功能简单，直接点函数要写短一点。这样带来另外一个好处，很好重用功能。
3？


-----------------------------------------------------------

10:47 2010-2-23

一眨眼，就过完年，这次过年让自己感触很深。有种说不出的感觉，或许自己年龄怎么突然那么大了。
然而看看自己还是那么的平庸。好几次自己都想再次努力，却一次次都被自己打倒。难道自己真的就那么等待命运的安排了，曾经的自己是那么向阳，很多东西都要求主动掌握在自己的手里，然后现在，真是是两个不同的自己。过年的那几天就写点东西，说下自己，说下自己的未来，计划下将来，回往下过去的点点滴滴。然而自己一直都静不下心来。好了写些其他的吧。



刚刚正在思考怎么实现一个视频播放器，只是现实单纯的传数据给他，然后就即时显示。
因为我要这个类的基础实现画矩形框等智能数据，我肯定不能把这个功能也加进这个类中，因为首先并不是用户一定需要显示，2耦合性太大了， 觉得应该用简单的功能的类，叠加实现一个负责的功能，而不是用一个复杂的类实现一个复杂的功能（这个想必很有人初期都是这种）。用第二种，以后添加功能又得改这个复杂的类，经过多次的修改后，这个会改的面目全非，而第一种就不是有这个问题，功能模块化，从而可读性好，所以维护简单，增加功能也非常的简单，基本上不改原先的稳定的代码。


-----------------------------------------------------------
10:37 2010-2-27
@@@@@@@@@@@@@@@@@@@@@@@@
###############
￥￥￥￥￥￥
昨天一直遇到可怪的问题，搞得我真想死，问题如下：
我写一个文字闪烁的控件和画线、矩形等图的控件，当两个控件都放在一个窗口上时，就会有问题。
文字闪烁的控件是用定时器做的，矩形等图的控件当然只做了鼠标键盘的处理，和重写了Paint。
当画线的控件没画时，闪烁的控件就不闪了，画上，就一切正常，所以超级奇怪？

追踪原因是：调用SetTime后，一直没收到Ontimer消息，也就是Ontimer函数一直没调用。
那为什么Ontimer没调用？
我自己调式排除了窗口没有显示，或者被遮盖。


后来在网上找资料才知道，
1. paint和Time消息是优先级很低的消息，window在消息队列会做处理，当很多时会过滤
2. paint 消息在会执行OnPaint()，这个消息需要调用beginPaint和EndPaint去移除，
   CPaintDC会在构造和析构分别调用。

我这边的情况是。在画图形的控件里，CPaintDC dc这样是放在几个简单的判断之后才会调用的，
所以在没有画图形之前我没有调用beginPaint和EndPaint，导致paint消息一直在消息队列里面。
导致一直在调用画图形。而time消息由于队列慢，以前也有这个消息而一直都没处理，就一直没处理。


-----------------------------------------------------------
9:23 2010-3-1
@@@@@@@@ 关于 C++ XX = {0}; @@@@@@@@

以下为根据我看汇编的结果 -  Release版，当然变量不能优化
1. 一般的常规类型的数组，比如： char a[10], int b[2][5],等。
  最终是调用memset实现

2. 结构体，包括自定义的和系统的
  汇编优化为对每个偏移4赋值为0（xor eax,eax，将eax赋予4位的偏移），只有2位的ax，
  ；类似于下面，下面是SYSTEMTIME的
0040101F  xor         eax,eax 
00401021  movzx       ecx,ax 
00401024  push        ecx  
00401025  push        edx  
00401026  push        esi  
00401027  push        offset string "%d, %d, %d" (4020E4h) 
0040102C  mov         dword ptr [esp+22h],eax 
00401030  mov         dword ptr [esp+26h],eax 
00401034  mov         dword ptr [esp+2Ah],eax 
00401038  mov         word ptr [esp+2Eh],ax 

3. 类
 基本跟结构一样，不同的是如果有类变量在private或者protetct里面就会编译通不过


4. 结构体数组
 和结构体一样
 下面是SYSTEMTIME[2] = {0}
 00413547  xor         eax,eax 
00413549  mov         dword ptr [ebp-7Ah],eax 
0041354C  mov         dword ptr [ebp-76h],eax 
0041354F  mov         dword ptr [ebp-72h],eax 
00413552  mov         dword ptr [ebp-6Eh],eax 
00413555  mov         dword ptr [ebp-6Ah],eax 
00413558  mov         dword ptr [ebp-66h],eax 
0041355B  mov         dword ptr [ebp-62h],eax 
0041355E  mov         word ptr [ebp-5Eh],ax 




以前看够有人这样写：
  SYSTEMTIME syt = {sizeof(SYSTEMTIME)},
  经过我调式，最后结果就是第一个数据变为 那个sizeof的结构，其他的都为赋值0，


注意以上Rlease版，在这种初始化他会有不会用的变量有些成员不赋值，也就是优化了。


@@@@@@@@ think @@@@@@@@
今天又有一个问题，没有很好的解决，然后自己把这个问题写进了Question中，
突然想好，部门建设的问题，如果每个人都写这个Question，然后每周向大家抛出，或者是大家的一个学习机会。


-----------------------------------------------------------

10:04 2010-3-3


经典的C++问题，
一. stl数据结构，如果节点是一个结构体，那么会在插进队列时候重新构造赋值一份，
原先的如果是栈分配，那么也会调析构，
下面代码会在push_back的时候，做两件事。
1. stl::list, 构造一份
2. CBuf(pBuf)做为临时变量调用析构，导致pBuf被delete，从而strcpy crach
struct CBuf
{
    String(char* p):pBuf(p){}
    ~String(){delete[] pBuf;}
    char* pBuf;
};
list<CBuf> a;
char* pBuf = new char[100];
a.push_back(CBuf(pBuf));
strcpy(pBuf, "123");  // <---- crach


二，关于CPaint， 在构造析构分别调用BeginPaint和EndPaint，从而删除消息队列的paint消息
   paint消息，和Time消息是 低优先级消息的概念。他会在消息队列很多时，
   插不进队列，也就是被过滤，当然是以前还有这样的消息没处理


-----------------------------------------------------------

15:34 2010-3-9

@@@@@@@@
知道有时候为什么 在用 swicth，在case里面有时候可以不打括号，有时候打却会编译报错？

  因为 当你报错了，说明你在case里面申明了变量， 虽然C++支持你在用的时候才申明，
  这个我觉得应该是VC的Bug吧。 没用其他编译器试过。 如果是 那么就是C++编译器的设计问题


@@@@@@@@
关于数据模型

一直都在思考一个数据库异步操作的模型。
今天似乎想到了点眉目，
添加，删除、修改这些操作是不需要返回的， 所以用异步发消息等手段处理
而查询，则使用将经常要用的数据放在内存中，然后查询直接查询内存。
那么这样做，必然就需要在添加删除修改时修改这个Memory DB。

其实现在想到的以前在dowshu就想过，只是没有将添加，删除、修改做为异步处理，不过这个异步处理还是有些复杂的，
比如如果操作失败怎么办，当然一般情况在你的代码没有bug的情况是很难会失败的，多半就是硬件和一些特殊的参数传入异常。
不过可以借助先修改内存，先检查，
 
最好是将数据全部放在看护进程里面，因为异步可能会导致某些数据没有及时 修改添加等



-----------------------------------------------------------
9:06 2010-3-13

这几天一直在研究C++模板方面的东西，或许是前几天写是前几天写代码用模板用上瘾了，
主要是我将一个类函数指针做为模板参数实现简洁优雅的代码，但是我一直都还有一个问题，

怎么去很好实现一个泛型编程实现 一个类模板调用指定一个 类变量 
比如：
先举一个最简单
struct AA
{
  template<class T>
  void Set(T v){}  // 当v为int则为a=v，当v为float给b赋值。
  int a;
  float b;
}

当然解决的方法有 
1. 特化处理void Set(T v)，
  缺点：但是如果很多岂不是要写多个，所以感觉很不好，当然可以用其他的类似特化的方式做，
2. 利用变量偏移，强制转类型，比如用户调用前传一个偏移，然后将this+offset的地址强制成输入的类型，
  缺点：不安全，程序的对与错取决于用户输入的偏移，然后偏移还是有一定的技术含量，牵涉类型的大小的计算和对齐
  优点：代码简洁

看有没有想函数指针模板一样，实现指定调用


-----------------------------------------------------------
11:44 2010-3-23

一直在思考，DVR跨平台的一些问题，以前就跨平台想过其最麻烦之一的界面移植，

今天就客户端的跨平台移植的想法， 碎碎念。。
现在的DVR的客户端由单纯的 PC机（包含window和linux，UNXI和Apple），进入到多方面发展的趋势。
比如现在可以支持手机（多平台手机智能系统），一些手持的电子设备（PDA，掌上电脑等）。
如何支持那么形形色色的东东，这比服务端更复杂。 还好，这些一些IT巨头公司们找就为这些铺好路。
最早就莫过于Java，Java因为他而风靡全世界。 
而我要将的是Adobe的Flex(flash). 你可能会将为什么不用Java做平台移植呢》他很成熟而且用的很广泛。
Java有他的硬伤，执行慢。 Flash不仅可以支持多平台，而且作为。net的方式，和符合现在BS模式的大势（所趋）。
而且对多媒体的支持是不用我说的。画质速度是很多东西没法比的。问题是他也支持H264.
现在看来他唯一的缺点就是不支持Apple的系统，与其说flash的Flex不支持Apple，还不如说Apple不想去支持。
这里面或者种种各方的利益吧。

现在我做个总结吧：
优势：
界面很好看，且可移植大部分平台
执行效率高，包括界面显示及多媒体的支持
劣势：
不支持Apple的手机等嵌入式设备(ex.IPhone,IPad)，这个可以
借助于Packager for iPhone和即将发布的Adobe AIR，开发者将能够脱离浏览器以独立应用的形式发布内容。开发者可以先创建应用，然后通过App Store和Marketplace发布应用，所发布的应用能够运行在多种设备上

不支持黑莓 


Flash Build 4 序列号
1424-4008-9664-3602-3439-1711 


-----------------------------------------------------------
9:40 2010-3-24

昨天一直闲着无聊。于是就看起书来，无聊间首先从书柜上拿了一本崭新的WPF，可能买来一直买看，还是这几天脑子里有点关于界面移植的想法。  于是翻了翻居然也翻了十几页，大概讲的就是WPF的由来和好处和不好，当然像很多书一样，介绍某样技术，大部分都是夸的多，而他现在的致命伤--速度极慢，却是一句带过，或者笔者认为性能会在以后慢慢优化，就好似Vista到win7，传说中性能有质的提升，不过以我看来到那个时候也不知道是几年后的事情了。 于是我笑了笑，把书放会我的书架，于是又拿起另外一本，C++ Primer， 无意间在翻目录表时，发现他又章节在说 怎么用类的变量指针，， 唉。。。 我心想里，这不是我一直在解决的 指定给某个类的变量赋值的 泛型方法吗？  真是很巧合。。 




-----------------------------------------------------------

11:07 2010-3-25
想想这段研究模板这些泛型编程比较多，就写一些最近一些模板的一些妙用把。

1.模板实现某个类的静态变量的多个实例

 在effective   C＋＋中page   32，条款7中   
  template<class   T>   
  class   NewHandleerSupport   
  {   
        public:   
        static   new_handler   set_new_handler(new_handler   p);   
        static   void   *   operator   new(size_t   size);   
  private:   
        static   new_handler   currentHandler;   
  }   
    
  template<class   T>   
  new_handler   NewHandlerSupport<T>::set_new_handler(new_handler   p)   
  {   
        new_handler   oldHanler   =currentHandler;   
        currentHandler=p;   
        return   oldHandler;   
  }   
    
  class   X:public   NewHandlerSupport<X>   
  {}   
这个很显然模板参数是没有点用的，但是因为定义了模板使静态成员变量currentHandler，
在没定义一个模板参数就有一个实例



17:33 2010-3-26

关于全部变量初始化顺序问题，
在同一个文件里面，谁先申明谁就先，当不在一个文件当中时，可以用下面的编译指令去改变，
一般(compiler) 这个参数是用以 CRT库我们最好不要使用。
  #pragma init_seg(compiler)
   #pragma init_seg(lib)
   #pragma init_seg(user)
   #pragma init_seg("user_defined_segment_name")


ex：
http://www.wangchao.net.cn/bbsdetail_39013.html
http://support.microsoft.com/kb/104248/zh-cn
　Visual C++ 提供了 #pragma init_seg 这样一个编译指令来控制一个翻译单位中对象的初始化顺序。打开 Visual C++ 自带的 CRT 源代码文件 cout.cpp，你会发现如下的语句：
　　#pragma warning(disable: 4074)
　　#pragma init_seg(compiler)
　　_CRTIMP2 ostream cout(&fout);
　　通过使用 #pragma init_seg(compiler) 这个指令，在 cout.cpp 文件中的所有对象都被放在 compiler 这个初始化组，这个组中的对象总是最先初始化和最后析构。当然，这个组是保留给微软 C/C++ 运行库使用的，我们不应该使用它。在我们自己的代码里，如果希望一些对象先于其他对象初始化，我们可以使用 #pragma init_seg(lib) 指令，放置在 lib 组的对象总是比 compiler 组的对象初始化晚，但要先于其他对象。#pragma init_seg 指令还有其他一些高级用法让你进行更细致的控制。




9:24 2010-3-29

A、关于几个编译的选项：

1. 对齐
#pragma pack(push, _AFX_PACKING)
#pragma pack(pop)

2. 去警告
#pragma warning( push )
#pragma warning( disable: 4121 )

#pragma warning( pop )

3. 宏定义
#pragma push_macro("malloc")
#undef malloc

#pragma pop_macro("malloc")

1. 解释 
    (1) #pragma push_macro("MACRO_NAME") 是把当前与宏 MACRO_NAME 相关联的字符串值保存到栈中; 
    (2) #pragma pop_macro("MACRO_NAME") 是把栈中之前保存的与宏 MACRO_NAME 相关联的字符串值重新关联到宏 MACRO_NAME 上. 
    
2. 说明 
    (1) 必须先用 push_macro 将宏 MACRO_NAME 所关联的字符串值压入栈, 然后才能用 pop_macro 将其弹出; 
    (2) 如果多次用 push_macro 将宏 MACRO_NAME 多次所关联的不同字符串值压入栈, 则栈中保存的是宏 MACRO_NAME 最后一次压入的, 即用 pop_macro 弹出的是宏 MACRO_NAME 最后一次 push_macro 入的; 
    (3) 用 push_macro 将多个宏压入栈中, 再用 pop_macro 弹出时, 弹出字符串值的规则不是"先进后出(FILO)"或"后进先出(LIFO)", 而是与 pop_macro 所要弹出的宏名相关.


本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/g5dsk/archive/2009/12/28/5088439.aspx


B、这么编译内联的文件
  一直以来我们都会发现在调式MFC库时，会跳转到Inl的MFC文件，
  这因为一直是因为是调式才进去的，也一直以为这是MFC为了调式才用这个东西。
  
今天突然发现这个是MFC如果设置静态编译，而设的内联方式，
说白了就是，别人在包含MFC某些类库的头文件的时候，在头文件里面由包含了的实现文件，
 MFC用inl文件后缀，这个文件其实没做什么特殊处理只是在文件中没有包含原本的头文件，
只是加了个#pragma once，防止重编译（包含多次编译），而我在自己的机器测试也发现inl文件，
VS2005默认是不处理的，也就是当作普通的txt文件，但是在头文件包含，那么他就会当做C，CPP这些代码编译处理

通过这个我也明白MFC工程有个静态编译的办法了，以前也一直以为是用MFC静态库和MFC动态库做的，
其实准确说来是 还要加上inl的方式，以后我在我写的库也用这一招， 
又学会一招。。 嘿嘿。。。。



C、std::advance  std::distance
  std::advance 得到位置
  std::distance 两个Iter之间的距离
    list<int>::iterator itr = i.begin();   
    advance(itr,2);   
    cout<<"itr forward two is: ";   
    cout<<*itr<<endl;   

    itr = i.begin();   
    list<int>::iterator _itr = i.end();   
    cout<<"the dinstance bewtreen itr and Itr is: ";   
    cout<<distance(itr,_itr)<<endl; 




















